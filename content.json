{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"个人主页","text":"$$\\mathfrak{XECADES}$$ $\\mathfrak{\\text{XDino}}$ $\\mathtt{DRINK\\space A\\space CUP\\space OF\\space TEA}$ $\\text{『优 放 鼓 微 载 泛 沦 淡 }$ $\\text{ 游 棹 檝 啸 浮 泛 胥 淡 }$ $\\text{ 卒 投 容 清 载 柏 而 流 }$ $\\text{ 岁 竿 裔 风 滞 舟 逝 水 }$ $\\text{ 。 ， 。 ， 。 ， 。 ，』}$","link":"/about/index.html"},{"title":"归档","text":"","link":"/archives/index.html"},{"title":"","text":"程序集合：https://xecades.github.io/other/programs/programs.html OI知识点：https://xecades.github.io/other/point/point.html 实用工具：https://xecades.github.io/other/tools/tools.html","link":"/other/index.html"},{"title":"OI历程","text":"$$\\huge\\color{lightblue}{\\mathit{2016}}$$$$\\mathfrak{Hello\\space World}$$ $$\\color{lightblue}{First\\space Half\\space Year}:第一次接触C$$$$\\color{lightblue}{9-19,13:53}:注册第一个OJ:openjudge$$$$\\color{lightblue}{9-29}:提交第一个程序:超级玛丽(WA)$$$$\\color{lightblue}{9-29}:第一次AC题目$$$$\\color{lightblue}{10-8}:AC超级玛丽$$$$\\color{lightblue}{10-8}:完成openjudge的1.1全部题目$$$$\\color{lightblue}{Second\\space Half\\space Year}:接触C++$$ $$\\huge\\color{lightblue}{\\mathit{2017}}$$$$\\mathfrak{New\\space Beginning}$$ $$\\color{lightblue}{First\\space Half\\space Year}:暂时中断OI学习$$$$\\color{lightblue}{Middle}:完全转入C++$$$$\\color{lightblue}{10-14,14:30\\sim16:30}:NOIP2017普及组初赛$$$$\\color{lightblue}{10-18,13:54}:注册洛谷账号$$$$\\color{lightblue}{10-30,12:38}:洛谷小小牛祭$$$$\\color{lightblue}{11+}:惊喜地得知进入复赛$$$$\\color{lightblue}{11-4,15：09}:洛谷小小犇祭$$$$\\color{lightblue}{11-11}:NOIP普及复赛，115分，二等$$$$\\color{lightblue}{11-22,12:58}:洛谷小牛祭$$ $$\\huge\\color{lightblue}{\\mathit{2018}}$$$$\\mathfrak{Fight\\space For\\space My\\space Future}$$ $$\\color{lightblue}{First\\space Half\\space Year}:学进阶C++$$$$\\color{lightblue}{Middle}:端正思想，认识的OI重要性$$$$\\color{lightblue}{Middle}:大幅度地学习信竞$$$$\\color{lightblue}{8+}:为了打牢基础，选择考普及组$$$$\\color{lightblue}{8-29,9:08}:洛谷小犇祭$$$$\\color{lightblue}{10-13,14:30\\sim16:30}:NOIP2018普及组初赛$$$$\\color{lightblue}{10-29,12:36}:洛谷中牛祭$$$$\\color{lightblue}{11-10}:NOIP普及复赛，180分，二等$$$$\\color{lightblue}{11-30,15:51}:洛谷中犇祭$$$$\\color{lightblue}{12+}:OI被父母认可$$ $$\\huge\\color{lightblue}{\\mathit{2019}}$$$$\\mathfrak{Well\\space Done}$$ $$\\color{lightblue}{1+}:在成都参加OI冬令营$$$$\\color{lightblue}{1-28,7:42}:洛谷大牛祭$$$$\\color{lightblue}{1-31}:洛谷AK100祭$$$$\\color{lightblue}{2\\pm}:报名参加洛谷网校提高组$$$$\\color{lightblue}{2-14}:理解了图论和DP的思想，没我想得那么难$$$$\\color{lightblue}{2-19,8:38}:洛谷大犇祭$$$$\\color{lightblue}{2-19}:洛谷绿名祭$$$$\\color{lightblue}{3-11}:一件大事,但不能说$$$$\\color{lightblue}{3-14}:第二件大事,也不能说$$$$\\mathfrak{Till\\space Now\\dots}$$","link":"/progress/index.html"},{"title":"标签","text":"HI THERE!!","link":"/tags/index.html"},{"title":"笔记","text":"算法贪心 贪心是只在对问题求解时总是做出当前看来是最好的选择 在使用贪心算法时，要求当前问题的每一个局部最优解是全局最优解 动态规划($DP$) $DP$全称为$Dynamic$ $Programming$ 动态规划是一种将问题分阶段求解的算法 通过利用先前阶段的计算结果快速得到后续阶段的结果，减少不必要的重复计算 状态的设计是解决动态规划问题的关键 设计状态时要考虑： 状态是否能够转移 转移的效率 求出所有所需状态的总时间复杂度 $DP$包含： 线性$DP$ 区间$DP$ 树形$DP$ 背包$DP$ 数位$DP$ 状压$DP$ 线性$DP$是在线性序列上进行$DP$的一类问题 某些线性$DP$实质是递归，例如求斐波那契数列的第$n$项 快速幂 折半计算，分治 代码实现： 123456789101112int pow(int a,int b)//a^b{ int ans=1,base=a; while(b) if(b&amp;1) { ans*=base; base*=base; b&gt;&gt;=1; } return ans;} 思想：$a^{11}=a^{2^0+2^1+2^3}$ 前缀和 $O(1)$的时间复杂度计算一个区间的和 $pre[\\space\\space]$用于计算前缀和，$a[\\space\\space]$为原数组 初始化: 1pre[i]=pre[i-1]+a[i];//循环执行 $pre[r]-pre[l-1]$为$a[l..r]$的和 一维的$pre[i]$表示$a[1..i]$的和 前缀和预处理$O(n)$，查询是$O(1)$ 一维前缀和示例程序 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;#define MAX 10000int a[MAX],pre[MAX]={0};int n,l,r;int main(){ cout&lt;&lt;\"How many numbers? \"; cin&gt;&gt;n; cout&lt;&lt;\"Enter \"&lt;&lt;n&lt;&lt;\" numbers:\"&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; pre[i]=pre[i-1]+a[i]; } cout&lt;&lt;\"From \"; cin&gt;&gt;l; cout&lt;&lt;\"To \"; cin&gt;&gt;r; cout&lt;&lt;\"a[\"&lt;&lt;l&lt;&lt;\"..\"&lt;&lt;r&lt;&lt;\"]=\"; cout&lt;&lt;pre[r]-pre[l-1]&lt;&lt;endl; return 0;} 运行结果 123456How many numbers? 10Enter 10 numbers:123 123 5 34 354 -12 54 -21 0 21From 3To 8a[3..8]=414 二维前缀和可以在不修改元数据的前提下，在$O(1)$下算出一个矩阵的数字和 二位前缀和应用容斥原理 $pre[\\space\\space][\\space\\space]$用于计算前缀和，$a[\\space\\space][\\space\\space]$为原数组 初始化: 12pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j]//容斥原理 记矩形左上角坐标为$[x1][y1]$，右下角坐标为$[x2][y2]$，则从此矩形的和求法如下 1pre[x2][y2]-pre[x1-1][y2]-pre[x2][y1-1]+pre[x1-1][y1-1] 二维的$pre[i][j]$表示从$a[1][1]$到$a[i][j]$的矩形和 二维前缀和示例程序 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;#define MAX 10000int a[MAX][MAX],pre[MAX][MAX]={0};int sizeA,sizeB;int x1,x2,y1,y2;int main(){ cout&lt;&lt;\"Size?(a*b) \"; scanf(\"%d*%d\",&amp;sizeA,&amp;sizeB); cout&lt;&lt;\"Enter the rectangle:\"&lt;&lt;endl; for(int i=1;i&lt;=sizeB;i++) { for(int j=1;j&lt;=sizeA;j++) { cin&gt;&gt;a[i][j]; pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j]; } } cout&lt;&lt;\"Point 1(a,b):\"; scanf(\"%d,%d\",&amp;x1,&amp;y1); cout&lt;&lt;\"Point 2(a,b):\"; scanf(\"%d,%d\",&amp;x2,&amp;y2); printf(\"Range (%d,%d) to (%d,%d),sum=\",x1,y1,x2,y2); cout&lt;&lt;pre[x2][y2]-pre[x1-1][y2]-pre[x2][y1-1]+pre[x1-1][y1-1]&lt;&lt;endl; return 0;} 运行结果 123456789101112Size?(a*b) 5*6Enter the rectangle:1 5 8 23 5-2 -54 34 0 31 1 1 1 00 0 23 43 432 32 44 98 -236 9 4 7 5Point 1(a,b):2,3Point 2(a,b):4,4Range (2,3) to (4,4),sum=102//从值为34的点到值为43的点 快读 用$getchar()$来读入每个字符，再计算出值 常见表示如下： 1234567891011121314151617inline int Read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;'0' || ch&gt;'9') { if(ch=='-') f=-1; ch=getchar(); } while(ch&gt;='0' &amp;&amp; ch&lt;='9') { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);//相当于x=x*10-'0' ch=getchar(); } return x*f;//正负号} 读入速度比较：假如有一个丧心病狂的输入数据，它生成的方法如下： 12345678910#include&lt;iostream&gt;using namespace std;int main(){ freopen(\"input.txt\",\"w+\",stdout); for(int i=1;i&lt;=1000000;i++) cout&lt;&lt;\"12345 \"; for(int i=1;i&lt;=1000000;i++) cout&lt;&lt;\"12345 \"; for(int i=1;i&lt;=1000000;i++) cout&lt;&lt;\"12345 \"; return 0;} 那么，如下程序用于验证$cin$、$scanf()$和$Read()$快慢 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;ctime&gt;#include&lt;iostream&gt;using namespace std;clock_t s,e;int a;inline int Read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;'0' || ch&gt;'9') { if(ch=='-') f=-1; ch=getchar(); } while(ch&gt;='0' &amp;&amp; ch&lt;='9') { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); } return x*f;}int main(){ freopen(\"input.txt\",\"r+\",stdin);//从input.txt中读入数据 //cin part cout&lt;&lt;\"cin takes \"; s=clock(); for(int i=1;i&lt;=1000000;i++) cin&gt;&gt;a; e=clock(); cout&lt;&lt;(double)(e-s)&lt;&lt;endl; //scanf() part cout&lt;&lt;\"scanf() takes \"; s=clock(); for(int i=1;i&lt;=1000000;i++) scanf(\"%d\",&amp;a); e=clock(); cout&lt;&lt;(double)(e-s)&lt;&lt;endl; //Read() part cout&lt;&lt;\"Read() takes \"; s=clock(); for(int i=1;i&lt;=1000000;i++) a=Read(); e=clock(); cout&lt;&lt;(double)(e-s)&lt;&lt;endl; return 0;} 在我的电脑上输出如下： 123cin takes 1984scanf() takes 2507Read() takes 191 由此可见，快读名不虚传 数据结构$STL$ $STL$是$Standard$ $Template$ $Library$的简称，中文名是“标准模板库”。 $STL$中包含如下头文件 $algorithm$，算法 $deque$，双端队列 $iterator$，迭代器 $vector$，可变长数组 $list$，表 $map$，一对一关联容器 $queue$，队列，线性表 $set$，排序不重存储 $multiset$，排序可重存储 $stack$，栈 $unity$，一对值，类是$pair$ 其余部分$OIer$暂时不需掌握 $priority$_$queue$是优先队列，本质是一个堆，在头文件$queue$中，资料 树状数组 树状数组的$lowbit$测试： 123456789101112#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define lowbit(x) (x&amp;(-x))int main(){ cout&lt;&lt;\"lowbit test:\"&lt;&lt;endl; for(int i=1;i&lt;=16;i++) printf(\"lowbit(%d)+%d=%d\\n\",i,i,lowbit(i)+i); cout&lt;&lt;endl; return 0;} 运行结果： 1234567891011121314151617lowbit test:lowbit(1)+1=2lowbit(2)+2=4lowbit(3)+3=4lowbit(4)+4=8lowbit(5)+5=6lowbit(6)+6=8lowbit(7)+7=8lowbit(8)+8=16lowbit(9)+9=10lowbit(10)+10=12lowbit(11)+11=12lowbit(12)+12=16lowbit(13)+13=14lowbit(14)+14=16lowbit(15)+15=16lowbit(16)+16=32 树状数组示意图： 树状数组可借鉴的资料 树状数组通常用于表示和 树状数组每个节点是它二进制下$lowbit$得的点的信息合并而来的 每次+=lowbit()查询一个点被包含在的位置 每次-=lowbit()查询$1~n$包含了哪些段 线段树 线段树是每个点储存一段信息的树 根节点储存所有线段的信息 线段树示意图： 如上图，若要查询$2$~$6$，则需查询的点有：$[2,3]$、$[4,5]$、$6$这三个节点 线段树每个节点是它左儿子和右儿子的信息合并而来的 线段树可用于取最大值、求和等操作 数学二进制 一个数的相反数的二进制表示是原数的二进制每一位取反再加$1$ $lowbit(x)=x$&amp;$(-x)$，其值二进制只会有$1$个$1$，标志$x$二进制下从后往前数$0$截止的位置 手动开平方$\\sqrt n$可以用如下方法计算 假设要求$\\sqrt{13}$的粗略值 $\\because3&lt;\\sqrt{13}&lt;4$ $\\therefore设 x=\\sqrt{13}-3$ $\\therefore\\sqrt{13}=3+x$ $\\therefore13=3^2+2\\times3x+x^2=9+6x+x^2$ $\\because x&lt;1$ $\\therefore x^2小到可以忽略不计$ $\\therefore 13=9+6x$ $解得x\\approx0.667$ $\\therefore\\sqrt{13}\\approx3+0.667=3.667,但一次计算,不精确$ $\\therefore继续设 x=\\sqrt{13}-3.667$ $平方:13=13.4469+7.334x+x^2$ $x^2忽略$ $\\therefore13.4469+7.334x=13$ $解得x\\approx-0.061$ $\\therefore\\sqrt{13}\\approx3.667+(-0.061)=3.606$ 和准确值$(3.605551275464…)$相差无几，要求更精确的值，多次计算即可 四位保存除法通常用于高精除以低精 例如求$123456789\\div45$的值和余数： $123456789\\div45=1’2345’6789\\div45$ $1/45=0$ $\\because1%45=1$ $\\therefore余数1接上2345计算即12345$ $\\therefore12345/45=274$ $\\because12345%45=15$ $\\therefore余数15接上6789计算即156789$ $\\therefore156789/45=3484$ $\\because156789%45=9$ $\\therefore123456789\\div45=2743484\\cdots9$ 系统常规操作 Win+R输入calc快速打开计算器 Win+R输入cmd快速打开命令行 Win+R输入explorer.exe重新显示桌面 Win+R输入notepad快速打开记事本 $win10$自带录屏工具用Win+G打开 $cmd$中”$&gt;$”是输出重定向，”$&lt;$”是输入重定向","link":"/note/index.html"},{"title":"OI知识点","text":"Ⅰ.基础算法 枚举 模拟 贪心 分治 Ⅱ.数据结构 二叉堆 二叉搜索树 并查集 $RMQ$($s-t$表) $LCA$($tarjan$,树上倍增) 树状数组 线段树 Ⅲ.基本数论 高精度 排列组合 进制转换 $Lucas$定理 容斥定理 $gcd$算法 $exgcd$算法 裴蜀定理 逆元 解同余方程(中国剩余定理) 线性筛求质数 欧拉函数 欧拉定理 费马小定理 线性筛求欧拉函数 卡塔兰数 斯特林数 Ⅳ.字符串算法 $KMP$(字符串匹配) $TRIE$(字典树) $HASH$(哈希) Ⅴ.图论 图的存储 最小生成树 最短路算法 有向图的拓扑排序 树上倍增 Ⅵ.动态规划($DP$) 最长上升子序列 最长公共子序列 $0-1$背包 完全背包 归并问题 数字三角形 有向无环图最短路 树形$DP$ 棋盘$DP$ 记忆化搜索 决策单调性优化 四边形不等式优化 Ⅵ.$STL$ $stack$ $queue$,$priority$_$queue$ $deque$ $map$ $set$ $bitset$ $algorithm$","link":"/other/point/point.html"},{"title":"程序集合","text":"自制编译器通过命令行的$g++$编译命令，对$C++$程序进行编译 下载/预览地址 中文转$ASCII$我不知道转换的是不是$ASCII$码$QwQ$ 程序生成两个代码，用于输出，一个汉字转为两个$ASCII$码 下载/预览地址 字符舞此程序只是显示字符 要进行视频转字符或图片转字符请下载附件 下载/预览地址 附件 程序集合包含我的部分有趣的程序 标签$1$为外观包装后的 标签$2$为测试用 下载/预览地址-1 下载/预览地址-2 沙盒建筑游戏部分电脑显示可能有问题 标签$1$为外观包装后的小地图版 标签$2$为大地图版(外观包装简陋) 原版请见程序集合中 下载/预览地址-1 下载/预览地址-2 倒计时倒计时程序 下载/预览地址 打方块部分电脑显示可能有问题 标签$1$为执行游戏的程序 标签$2$为实时显示的程序 先运行标签$1$的程序，再运行标签$2$的程序 下载/预览地址-1 下载/预览地址-2 判断质数基础的判断质数程序 下载/预览地址 当前时间调用$windows.h$实时输出在线时间 下载/预览地址","link":"/other/programs/programs.html"},{"title":"好工具推荐","text":"$\\color{lightblue}{\\mathit{Visual\\space Studio\\space Code}}$$$轻便实用有内涵的代码编辑器$$ $\\color{lightblue}{\\mathit{Glasslt-VSC}}$$$VSCode里超好用的透明背景插件$$ $\\color{lightblue}{\\mathit{Mathcha}}$$$方便的数学公式书写器$$ $\\color{lightblue}{\\mathit{RUNOOB}}$$$电脑知识学习网站$$ $\\color{lightblue}{\\mathit{W3school}}$$$Web编程学习网站$$ $\\color{lightblue}{\\mathit{Font\\space Awesome}}$$$在线图标资源库$$ $\\color{lightblue}{\\mathit{DiskGenius}}$$$U盘修复工具$$ $\\color{lightblue}{\\mathit{Dino}}$$$码累了，消遣的小恐龙(chrome浏览器)$$ $\\color{lightblue}{\\mathit{Smallpdf}}$$$很多PDF的方便工具$$ $\\color{lightblue}{\\mathit{OIerDb}}$$$信息学数据库$$ $\\color{lightblue}{\\mathit{OI\\space Wiki}}$$$信息学百科知识$$ $\\color{lightblue}{\\mathit{Visual\\space C++文档}}$$$Microsoft的C++文档百科$$ $\\color{lightblue}{\\mathit{Removebg}}$$$在线抠图工具$$ $\\color{lightblue}{\\mathit{Mini\\space Tag\\space Cloud}}$$$在线生成词云文字$$ $\\color{lightblue}{\\mathit{Nice\\space Tool}}$$$一些好用的工具$$ $\\color{lightblue}{\\mathit{九条命Email}}$$$免费提供10分钟免注册邮箱服务$$ $\\color{lightblue}{\\mathit{\\LaTeX公式}}$$$真正良心洛谷博客$$ $\\color{lightblue}{\\mathit{CNKI翻译助手}}$$$厌倦百度翻译和谷歌翻译的用这个$$","link":"/other/tools/tools.html"},{"title":"联系我","text":"社交账号 用户名 账号 $QQ$ 天蓝. $2135174618$ $QQ$小号$^*$ . $3499412089$ 微信$^*$ 天蓝. $a2135174618$ $email$ 天蓝. $a1227253013@qq.com$ $email$ 天蓝. $2135174618@qq.com$ 网易邮箱$^*$ 天蓝. $a1227253013@163.com$ 洛谷 天蓝 $UID:64434$ $openjudge$ 天蓝. $a1227253013@qq.com$ $CODE[VS]$ 天蓝. $a1227253013@qq.com$ $Github$ $aaadsgfh$ $a1227253013@qq.com$ $Github$另号$^*$ $waterdrop123$ $2135174618@qq.com$ $MOOC^*$ 天蓝$aaad$ $QQ$登录 $TMOOC$ $aaads$ $a1227253013@qq.com$ $CodeForces$ $aaads$ $a1227253013@qq.com$ $POJ^*$ $Fairy$_$Tale$ $Fairy$_$Tale$ $LibreOJ$ $aaadsgfh$ $aaadsgfh$ $RQNOJ^*$ 天蓝. 天蓝. $Judge$ $Duck$ $Online$ $tianlan$ $tianlan$ 我的世界中国版 $aaadsgfh$ $a1227253013@163.com$ 百度网盘 天蓝呵呵呵 $QQ$登录 $\\dots$ $\\dots$ $\\dots$ $\\color{green}{//不常用账号右上角标*}$ $\\color{green}{//奇葩用户名请勿吐槽}$","link":"/other/account/account.html"}],"posts":[{"title":"世界难题(滑稽)","text":"这是一道语文阅读题 仅供娱乐，请勿当真 四、现代文阅读 阅读下面短文，完成10-15题。 15._________________ ①寒风呼啸的帝都，万千灯火中的一点明亮下，一个孩子正拿着数学作业立于书桌一旁。 ②“孩子，真抱歉，”已埋头于书桌前许久的父亲，抹了抹额上渗出的汗珠，“现在的题目，比以前真难了不是一点点……” ③“爸，你可是北大毕业生啊……” ④父亲尴尬一笑，笑中有愧。 ⑤这时，家中的保姆恰巧经过桌前，一瞥桌前卷子，顺手抄起一支笔，文字，数字像蝼蚁一般在草稿纸上排起了队。” ⑥“你还是继续忙你吧……”父亲不耐烦的挥了挥手，脸上带着不屑。保姆不答，脸上毫无表情。 ⑦须臾，题得解，父亲看着草稿纸上精妙而富有条理的解题，脸上满是惊愕，“莫……莫非，你老家是……?” ⑧“四川，绵阳”。保姆答，脸上依旧毫无表情。 ⑨北风像野兽一样继续敲打着窗户…… 10、首尾两段的描写各有什么作用？（4分） 答：①“寒风呼啸的帝都，万千灯火中的一点明亮下”：渲染了阴沉的气氛，烘托人物忧伤的心情，推动情节发展，为下文北大毕业的父亲解不出数学题作铺垫。称“帝都”而非“北京”，强调出北京在高考中的王霸地位，与后文“四川”在称谓上形成鲜明对比，暗示主题，“万千灯火中的一点明亮下”指出帝都的繁华，暗示像父亲一样的北大毕业生在北京比比皆是，巧妙地揭示出高考的地域不公。②“北风像野兽一样继续敲打着窗户……”：呼应开头“寒风呼啸”，升华主题，用野兽比喻寒风，暗示不公平的高考政策像“野兽”一样吃肉不吐骨头。省略号表示寒风会持续吹刮，暗示这样的高考地域不公平会一直持续下去。 11、找出几处小说的细节描写，并分析其作用。（4分） 答：①“已埋头于书桌前许久的父亲，抹了抹额上渗出的汗珠”：“埋头”写出了父亲解题之认真，“许久”写出父亲解题时间之长。“渗出的汗珠”写出了数学题之难。②“一瞥桌前卷子”“顺手抄起一支笔”：“ 一瞥”“顺手”写出了保姆解题能力之高超，早已成竹在胸。从中可见四川高考生解题数量之多，速度之快，正确率之高，兴趣之浓厚。 12、画线句“脸上毫无表情”两处重复，含义有何不同？（2分） 答：①第一处“脸上毫无表情”，生动地写出了保姆解题时的专心致志，对父亲的话恍如未闻。②第二处“脸上依旧毫无表情”，写出了保姆深受四川高考政策的伤害之深，早已精神麻木。 13、本文的结尾有什么特点？（3分） 答：用了欧亨利式的结尾，既在意料之外又在情理之中，给读者心灵的震撼，引发读者思考，巧妙委婉地抨击了四川高考政策。 14、本文的语言风格有什么特点？（2分） 答：①精炼传神。②带有文言色彩，典雅质朴。 15、下面作为小说题目，最恰当的一项是（ ）（3分） A、发生在帝都的一件事 B、笨爸爸 C、聪明的保姆 D、可恶的四川高考 答：D","link":"/2019/06/21/AFunnyTask/"},{"title":"动态规划-01背包问题","text":"有$N$件物品和一容量为$V$的背包。第$i$件物品的费用为c[i]，价值为w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这是一道$01$背包的题，这个问题的特点是：每种物品只有一件，可以选择放或者不放。 算法基本思想利用动态规划思想，子问题为：f[i][v]表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。 其状态转移方程是： 12f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]};//这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。 解释一下上面的方程：“将前$i$件物品放入容量为$v$的背包中”这个子问题，如果只考虑第$i$件物品放或者不放，那么就可以转化为只涉及前$i-1$件物品的问题，即： 如果不放第$i$件物品，则问题转化为“前$i-1$件物品放入容量为$v$的背包中”。 如果放第$i$件物品，则问题转化为“前$i-1$件物品放入剩下的容量为v-c[i]的背包中”（此时能获得的最大价值就是f[i-1][v-c[i]]再加上通过放入第$i$件物品获得的价值w[i]）。 则f[i][v]的值就是$1$、$2$中最大的值。 注意f[i][v]有意义当且仅当存在一个前$i$件物品的子集，其费用总和为$v$。所以按照这个方程递推完毕后，最终的答案并不一定是f[N][V]，而是f[N][0..V]的最大值。 优化空间复杂度以上方法的时间和空间复杂度均为$O(N*V)$，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到$O(V)$。 上面f[i][v]使用二维数组存储的，可以优化为一维数组f[v]，将主循环改为： 123for i=1..N;for v=V..0;f[v]=max{f[v],f[v-c[i]]+w[i]}; 即将第二层循环改为从$V..0$，逆序。 举个栗子假设最大容量$M=10$，物品个数$N=3$，物品大小$w$是{$3,4,5$}，物品价值$p$是{$4,5,6$}。 当进行第$i$次循环时，f[v]中保存的是上次循环产生的结果，即第$i-1$次循环的结果$(i&gt;=1)$。所以f[v]=max{f[v],f[v-c[i]]+w[i]}这个式子中，等号右边的f[v]和f[v-c[i]]+w[i]都是前一次循环产生的值。 当$i=1$时，f[0..10]初始值都为$0$。所以： 1234567f[10]=max{f[10],f[10-c[1]]+w[1]}=max{0,f[7]+4}=max{0,0+4}=4;f[9]=max{f[9],f[9-c[1]]+w[1]}=max{0,f[6]+4}=max{0,0+4}=4;... ...f[3]=max{f[3],f[3-c[1]]+w[1]}=max{0,f[3]+4}=max{0,0+4}=4;f[2]=max{f[2],f[2-c[1]]+w[1]}=max{0,f[2-3]+4}=0;//数组越界？f[1]=0;f[0]=0; 当$i=2$时，此时f[0..10]经过上次循环后，都已经被重新赋值，即f[0..2]=0,f[3..10]=4。利用f[v]=max{f[v],f[v-c[i]]+w[i]}这个公式计算$i=2$时的f[0..10]的值。 当$i=3$时，同理。 具体的值如下表所示： 因此，利用逆序循环就可以保证在计算f[v]时，公式f[v]=max{f[v],f[v-c[i]]+w[i]}中等号右边的f[v]和f[v-c[i]]+w[i]保存的是f[i-1][v]和f[i -1][v-c[i]]的值。 当$i=N$时，得到的f[V]即为要求的最优值。 初始化的细节问题在求最优解的背包问题中，一般有两种不同的问法： 要求“恰好装满背包”时的最优解 求小于等于背包容量的最优解，即不一定恰好装满背包。 这两种问法，在初始化的时候是不同的。 要求恰好装满背包时的最优解： 在初始化时除了f[0]为$0$其它f[1..V]均设为$-∞$，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。如果不能恰好满足背包容量，即不能得到f[V]的最优值，则此时f[V]=-∞，这样就能表示没有找到恰好满足背包容量的最优值。 求小于等于背包容量的最优解，即不一定恰好装满背包： 如果并没有要求必须把背包装满，而是只希望价值尽量大，初始化时应该将f[0..V]全部设为$0$。 总结$01$背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成$01$背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 01背包问题代码解法一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MIN=0x80000000;const int N=3; //物品数量const int V=5; //背包容量int f[N+1][V+1];int Package(int *W,int *C,int N,int V);int main(){ int W[4]= {0,7,5,8}; //物品权重 int C[4]= {0,2,3,4}; //物品大小 int result=Package(W,C,N,V); if(result&gt;0) { cout&lt;&lt;endl&lt;&lt;\"the opt value:\"&lt;&lt;result&lt;&lt;endl; int i=N,j=V; while(i) { if(f[i][j]==(f[i-1][j-C[i]]+W[i])) { cout&lt;&lt;i&lt;&lt;\":\"&lt;&lt;\"w=\"&lt;&lt;W[i]&lt;&lt;\",c=\"&lt;&lt;C[i]&lt;&lt;endl; j-=C[i]; } i--; } } else cout&lt;&lt;\"can not find the opt value\"&lt;&lt;endl; return 0;}int Package(int *W,int *C,int N,int V){ int i,j; memset(f,0,sizeof(f)); //初始化为0 for(i=0; i&lt;=N; i++) for(j=1; j&lt;=V; j++) //此步骤是解决是否恰好满足背包容量， f[i][j]=MIN; //若“恰好”满足背包容量，即正好装满背包 //则加上此步骤，若不需要“恰好”，则初始化为0 for(i=1; i&lt;=N; i++) for(j=C[i]; j&lt;=V; j++) { f[i][j]=(f[i-1][j] &gt; f[i-1][j-C[i]]+W[i]) ? f[i-1][j] : (f[i-1][j-C[i]]+W[i]); cout&lt;&lt;\"f[\"&lt;&lt;i&lt;&lt;\"][\"&lt;&lt;j&lt;&lt;\"]=\"&lt;&lt;f[i][j]&lt;&lt;endl; } return f[N][V];} 解法二 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MIN=0x80000000;const int N=3; //物品数量const int V=5; //背包容量int f[V+1];int Package(int *W,int *C,int N,int V);int main(){ int W[4]= {0,7,5,8}; //物品权重 int C[4]= {0,2,3,4}; //物品大小 int result=Package(W,C,N,V); if(result&gt;0) { cout&lt;&lt;endl; cout&lt;&lt;\"the opt value:\"&lt;&lt;result&lt;&lt;endl; } else cout&lt;&lt;\"can not find the opt value\"&lt;&lt;endl; return 0;}int Package(int *W,int *C,int N,int V){ int i,j; memset(f,0,sizeof(f)); //初始化为0 for(i=1; i&lt;=V; i++) //此步骤是解决是否恰好满足背包容量， f[i]=MIN; //若“恰好”满足背包容量，即正好装满背包 //则加上此步骤，若不需要“恰好”，则初始化为0 for(i=1; i&lt;=N; i++) for(j=V; j&gt;=C[i]; j--)//注意此处与解法一是顺序不同的，弄清原因 { f[j]=(f[j] &gt; f[j-C[i]]+W[i]) ? f[j] : (f[j-C[i]]+W[i]); cout&lt;&lt;\"f[\"&lt;&lt;i&lt;&lt;\"][\"&lt;&lt;j&lt;&lt;\"]=\"&lt;&lt;f[j]&lt;&lt;endl; } return f[V];} 本文转载$fly1988happy$的文章 原作者参考： http://blog.sina.com.cn/s/blog_4cd99cfa0100mer2.html http://www.cnblogs.com/tanky_woo/archive/2010/07/31/1789621.html 向原作者表示感谢(侵删)！","link":"/2019/06/28/Backpack/"},{"title":"高精度计算代码","text":"以下列举了一些常用的高精度计算代码 高精加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;struct LargeInt{ int len; int num[100001];};LargeInt a,b,ans;string c,d;void Input();void Plus();int main(){ Input(); Plus(); for(int i=ans.len;i&gt;=1;i--) cout&lt;&lt;ans.num[i]; cout&lt;&lt;endl; return 0;}void Input(){ cin&gt;&gt;c&gt;&gt;d; a.len=c.length(); b.len=d.length(); for(int i=0;i&lt;a.len;i++) a.num[a.len-i]=c[i]-'0'; for(int i=0;i&lt;b.len;i++) b.num[b.len-i]=d[i]-'0';}void Plus(){ ans.len=max(a.len,b.len); for(int i=1;i&lt;=ans.len;i++) { ans.num[i]+=a.num[i]+b.num[i]; ans.num[i+1]+=ans.num[i]/10; ans.num[i]%=10; } if(ans.num[ans.len+1]!=0) ans.len++;} 高精减123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;struct LargeInt{ int len; int num[100001];}a,b,ans;string c,d;bool negative;void Input();void Minus();int main(){ Input(); Minus(); if(negative) cout&lt;&lt;\"-\"; for(int i=ans.len;i&gt;=1;i--) cout&lt;&lt;ans.num[i]; cout&lt;&lt;endl; return 0;}void Input(){ cin&gt;&gt;c&gt;&gt;d; if(c.length()&lt;d.length() || (c.length()&lt;d.length() &amp;&amp; c&lt;d)) { negative=true; swap(c,d); } a.len=c.length(); b.len=d.length(); for(int i=0;i&lt;a.len;i++) a.num[a.len-i]=c[i]-'0'; for(int i=0;i&lt;b.len;i++) b.num[b.len-i]=d[i]-'0';}void Minus(){ ans.len=a.len; for(int i=1;i&lt;=ans.len;i++) { if(a.num[i]&lt;b.num[i]) { a.num[i+1]--; a.num[i]+=10; } ans.num[i]+=a.num[i]-b.num[i]; } while(ans.num[ans.len]==0 &amp;&amp; ans.len!=1) ans.len--;} 高精乘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;struct LargeInt{ int len; int num[100001];}a,b,ans;string c,d;void Input();void Multiply();int main(){ Input(); Multiply(); for(int i=ans.len;i&gt;=1;i--) cout&lt;&lt;ans.num[i]; cout&lt;&lt;endl; return 0;}void Input(){ cin&gt;&gt;c&gt;&gt;d; a.len=c.length(); b.len=d.length(); for(int i=0;i&lt;a.len;i++) a.num[a.len-i]=c[i]-'0'; for(int i=0;i&lt;b.len;i++) b.num[b.len-i]=d[i]-'0';}void Multiply(){ int x; for(int i=1;i&lt;=a.len;i++) { x=0; for(int j=1;j&lt;=b.len;j++) { ans.num[i+j-1]+=a.num[i]*b.num[j]+x; x=ans.num[i+j-1]/10; ans.num[i+j-1]%=10; } ans.num[i+b.len]=x; } ans.len=a.len+b.len; while(ans.num[ans.len]==0 &amp;&amp; ans.len!=1) ans.len--;} 高精除低精12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=10e9;int b,i,la,lc,x;int a[MAX],c[MAX];string str;int main(){ memset(a,0,sizeof(a)); memset(c,0,sizeof(c)); cin&gt;&gt;str&gt;&gt;b; la=str.length(); for(i=0;i&lt;la;i++) a[la-i-1]=str[i]-'0'; x=0; for(i=la-1;i&gt;=0;i--) { c[i]=(x*10+a[i])/b; x=(x*10+a[i])%b; } lc=la; while(lc&gt;1 &amp;&amp; c[lc-1]==0)lc--; for(i=0;i&lt;lc;i++) cout&lt;&lt;c[lc-i-1]; cout&lt;&lt;\" \"&lt;&lt;x&lt;&lt;endl; return 0;} 综合起来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const int MAX_SIZE=10e9;struct Int{ int len,n[MAX_SIZE]; void Set(intl) { len=l; for(inti=1;i&lt;=len;i++) n[i]=0; } Int(char* s) { len=strlen(s); for(inti=len-1;~i;i--) { if(s[i]&lt;='9' &amp;&amp; s[i]&gt;='0') { len=i+1; break; } } for(int i=len;i&gt;=1;i--) n[i]=s[len-i]-'0'; } Int(long long x=0) { len=0; do { n[++len]=x%10; x/=10; }while(x); } bool operator&lt;(const Int b) { if(len!=b.len) return len&lt;b.len; for(int i=len;i;i--) if(n[i]!=b.n[i]) return n[i]&lt;b.n[i]; return false; } Int operator+(const Int b)const { Int ans; ans.Set(max(len,b.len)+1); for(int i=1;i&lt;=ans.len;i++) { if(i&lt;=len) ans.n[i]+=n[i]; if(i&lt;=b.len) ans.n[i]+=b.n[i]; ans.n[i+1]+=ans.n[i]/10; ans.n[i]%=10; } while(!ans.n[ans.len] &amp;&amp; ans.len&gt;1)ans.len--; return ans; } Int operator-(const Int b) { Int ans,a=*(this); ans.Set(len); for(int i=1;i&lt;=ans.len;i++) { if(a.n[i]&lt;b.n[i]) a.n[i+1]--,a.n[i]+=10; ans.n[i]+=a.n[i]-(i&gt;b.len?0:b.n[i]); } while(!ans.n[ans.len] &amp;&amp; ans.len&gt;1)ans.len--; return ans; } Int operator*(Int b) { Int ans; ans.Set(len+b.len); for(int i=1;i&lt;=len;i++) { for(int j=1;j&lt;=b.len;j++) { ans.n[i+j-1]+=n[i]*b.n[j]; ans.n[i+j]+=ans.n[i+j-1]/10; ans.n[i+j-1]%=10; } } while(!ans.n[ans.len] &amp;&amp; ans.len&gt;1)ans.len--; returnans; } Int operator/(const int &amp;b)//高除低 { if(*this&lt;Int(b)) return Int(0LL); Int ans;ans.len=len; int r=0; for(int i=ans.len;i;i--) { r=r*10+n[i]; ans.n[i]=r/b; r%=b; } while(ans.len&gt;1 &amp;&amp; !ans.a[ans.len])ans.len--; return ans; } Int operator/(const Int b)//高除高 { if((*this)&lt;b) return Int(0LL); Int ans; ans.Set(len-b.len+1); for(int i=ans.len;i;i--) { for(int j=1;j&lt;=9;j++) { ans.n[i]++; if(*this&lt;ans*b) { ans.n[i]--; break; } } } while(ans.len&gt;1 &amp;&amp; !ans.n[ans.len])ans.len--; return ans; } void print() { for(int i=len;i;i--) cout&lt;&lt;n[i]; cout&lt;&lt;endl; }};","link":"/2019/06/30/BigNumCalc/"},{"title":"位运算的应用","text":"位运算的含义见前文 本文介绍位运算的简单应用及性质 优先级同其他运算符号一样，位运算也是有优先级的： 优先级 运算符 1 ~ 2 &lt;&lt;、&gt;&gt; 3 &amp; 4 ^ 5 | 6 &amp;=、^=、|=、&lt;&lt;=、&gt;&gt;= 常用变换列举如下： 操作 举例 运算 去掉最后一位 $101101\\rightarrow 10110$ $x$ &gt;&gt; $1$ 在最后加一个0 $101101\\rightarrow 1011010$ $x$ &lt;&lt; $1$ 在最后加一个1 $101101\\rightarrow 1011011$ $x$ &lt;&lt; $1+1$ 把最后一位变成1 $101100\\rightarrow 101101$ $x$ | $1$ 把最后一位变成0 $101101\\rightarrow 101100$ $x$ | $1-1$ 最后一位取反 $101101\\rightarrow 101100$ $x$ ^ $1$ 把右数第k位变成1 $101001\\rightarrow 101101,k=3$ $x$ | $(1$&lt;&lt;$(k-1))$ 把右数第k位变成0 $101101\\rightarrow 101001,k=3$ $x$ &amp; ~ $(1$ &lt;&lt; $(k-1))$ 右数第k位取反 $101001\\rightarrow 101101,k=3$ $x$ ^ $(1$ &lt;&lt; $(k-1))$ 取末k位 $1101101\\rightarrow 1101,k=4$ $x$ &amp; $15^※$ 取右数第k位 $1101101\\rightarrow 1,k=4$ $x$ &gt;&gt; $(k-1)$ &amp; $1$ 把末k位变成1 $101001\\rightarrow 101111,k=4$ $x$ | $(1$ &lt;&lt; $k-1)$ 末k位取反 $101001\\rightarrow 100110,k=4$ $x$ ^ $(1$ &lt;&lt; $k-1)$ 把右边连续的1变成0 $100101111\\rightarrow 100100000$ $x$ &amp; $(x+1)$ 把右起第一个0变成1 $100101111\\rightarrow 100111111$ $x$ | $(x+1)$ 把右边连续的0变成1 $11011000\\rightarrow 11011111$ $x$ | $(x-1)$ 取右边连续的1 $100101111\\rightarrow 1111$ ($x$ ^ $(x+1))$ &gt;&gt; $1$ 去掉右起第一个1的左边($lowbit$) $100101000\\rightarrow 1000$ $x$ &amp; ~ $(x$ ^ $(x-1))$或$x$ &amp; $(-x)$ ※其中取末$4$位用$x$ &amp; $15$是因为$15$二进制表示为$1111$.因此，取末尾$8$位用二进制为$11111111$的数，转为十进制为$255$，建议用$(1$ &lt;&lt; $8$) $-$ $1$表示 常用应用交换数字1234567891011121314#include&lt;iostream&gt;using namespace std;int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; //swap a=a^b; b=a^b; a=a^b; //end cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b; return 0;} 也可用 1234void swap(int *a,int *b){ (*a)^=(*b)^=(*a)^=(*b); } 计算32位整数的二进制中1的个数的奇偶性当输入数据的二进制表示里有偶数个数字1时程序输出0，有奇数个时输出1（注意：对于32位整数） 1234567891011121314#include&lt;iostream&gt;using namespace std;int main(){ int x; cin&gt;&gt;x; x^=(x&gt;&gt;1); x^=(x&gt;&gt;2); x^=(x&gt;&gt;4); x^=(x&gt;&gt;8); x^=(x&gt;&gt;16); cout&lt;&lt;(x&amp;1); return 0;} 获得int最大值(Max_Int)123456int Max_Int(){ return (1&lt;&lt;31)-1; //或return ~(1&lt;&lt;31); //或return (1&lt;&lt;-1)-1;} 获取int最小值(Min_Int)12345int Min_Int(){ return 1&lt;&lt;31; //或return 1&lt;&lt;-1;} 取绝对值1234int abs(int x){ return (x^(x&gt;&gt;31))-(x&gt;&gt;31);} 取较大值1234int max(int x,int y){ return x^((x^y)&amp;-(x&lt;y));} 取较小值1234int min(int x,int y){ return y^((x^y&amp;-(x&lt;y)));} 从低到高,取n的第m位1234int getBit(int n, int m){ return (n&gt;&gt;(m-1))&amp;1;} 从低到高,将n的第m位置11234int setBitToOne(int n, int m){ return n|(1&lt;&lt;(m-1));} 从低到高,将n的第m位置01234int setBitToZero(int n, int m){ return n&amp;~(1&lt;&lt;(m-1));} 计算n+11-~n 计算n-11~-n 计算-n1~n+1 完~ 本文修改自$nash$_的文章和百度百科","link":"/2019/06/27/BitwiseOperationUsage/"},{"title":"位运算的操作","text":"引言程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。 C++中常用的位运算操作符有6个： 含义 运算符举例 英文表示 按位与 $a$ &amp; $b$ $and$ 按位或 $a$ | $b$ $or$ 按位异或 $a$ ^ $b$ $xor$ 按位取反 ~ $a$ $not$ 左移 $a$ &lt;&lt; $b$ $shl$ 右移(带符号) $a$ &gt;&gt; $b$ $shr$ 按位与&amp;对于相同位，同有则有，一无则无。 即：相同位的两个数字同为1，则为1；有一个不为1，则为0。 举例1231 &amp; 1 = 11 &amp; 0 = 00 &amp; 0 = 0 则$5\\space and\\space 28$为: 1234 00101 //5&amp; 11100 //28------- 00100 //4 即$5\\space and\\space 28\\space =\\space 4$ 作用$and$运算常用于二进制的取位操作，可以判断整数的奇偶性(二进制末尾是0为偶数，是1为奇数)。一个数 $and$ $1$就取二进制下的最后一位。 按位或|对于相同位，一有则有，同无则无。 即：相同位的两个数字只要有一个为1，则为1；否则为0。 举例1231 | 1 = 11 | 0 = 10 | 0 = 0 则$5\\space or\\space 28$为: 1234 00101 //5| 11100 //28------- 11101 //29 作用$or$运算常用于二进制下的赋值，一个数 $or$ $1$把二进制末尾的数变成1，即把这个数变成大于或等于原数的最小奇数($22$ | $1$ $=$ $23$ ; $23$ | $1$ $=$ $23$ ; $-10$ | $1$ $=$ $-9$)，若要让其变为偶数，把它 $or$ $1$后减一即可。 按位异或^对于相同位，不同则有，相同则无。 即：相同位的两个数字不同则为1；相同则为0。 举例1231 ^ 1 = 01 ^ 0 = 10 ^ 0 = 0 则$5\\space xor\\space 28$为: 1234 00101 //5^ 11100 //28------- 11001 //25 作用有趣的是，$xor$操作的逆运算是其本身，即两次异或同一个数后结果不变：$(a$ ^ $b)$ ^ $b$ $=$ $a$。因此，$xor$可用于简单加密： 若原文为$123456789$，密钥为$10086$，加密得密文: 1123456789 ^ 10086 = 123464307‬ 要解密，再次异或密钥即可： 1123464307‬ ^ 10086 = 123456789 按位取反~无则有，有则无。 即：把1换成0，0换成1。 举例12~ 1 = 0~ 0 = 1 C++中取反运算实例： 123456789#include&lt;iostream&gt;using namespace std;int main(){ unsigned short a=100; a=~a; cout&lt;&lt;a; return 0;} 输出$65435$但若运行如下代码： 12345678#include&lt;iostream&gt;using namespace std;int main(){ unsigned short a=100; cout&lt;&lt;~a; return 0;} 输出$-101$即有符号类型和无符号类型取反效果不同。 左移&lt;&lt;$a$ &lt;&lt; $b$把二进制下的$a$后面添加$b$个0。 举例1234(所有数字在十进制下表示)1 &lt;&lt; 2 = 4 //1001 &lt;&lt; 10 = 1024 //‭10000000000‬2 &lt;&lt; 3 = 16 //10000 作用看到例子，你发现了什么？ $$1 &lt;&lt; 2 = 4 = 1\\times 2^2$$ $$1 &lt;&lt; 10 = 1024 = 1\\times 2^{10}$$ $$2 &lt;&lt; 3 = 16 = 2\\times 2^3$$ 对！$a$ &lt;&lt; $n = a\\times 2^n$，要计算$2^n$，可以不用$pow()$，用左移运算$(1$ &lt;&lt; $n)$，要快得多。定义常量也可以用左移运算:$1$ &lt;&lt; $16$ $-$ $1$可以表示$65535$. 右移&gt;&gt;$a$ &gt;&gt; $b$把二进制下的$a$向右移$b$位，低位舍去，高位补0。 举例1234 &gt;&gt; 2 = 11024 &gt;&gt; 5 = 321000 &gt;&gt; 10 = 0 作用和左移类似，$a$ &gt;&gt; $b$相当于$\\lfloor a\\div 2^b\\rfloor$(取整)，因此可以用&gt;&gt; $1$代替$\\div 2$ 位运算的应用见续文完~","link":"/2019/06/27/BitwiseOperation/"},{"title":"你好，世界","text":"当初，在$2016$年，当我伴随着老师的引导，在电脑中一字一顿地敲出那$Hello$ $World$的时候，我的心情是忐忑的，我不知道今后的路会怎样，也不知道今后的进展又会如何。 根据我的回忆，我的$Hello$ $World$是这样的： 1234567#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){printf(\"Hello World\");return 0;} 我按下那个陌生而又神秘的编译按钮，出现的不再是以往的$Error$，我的面前出现了一个小黑框，上面绣着一个个灵动小巧的英文字母，它们组成了一个难以令我忘怀的句子：$Hello$ $World$。 我永远无法忘怀我的激动：这可是我第一个程序啊！ 很多人都或多或少有着类似的经历。现在，回首往事，我们已经历经了无数的岁月，经历了无数的坎坷，无论困难多大，我们只需要坚信那一句话： $Hello$ $World$","link":"/2019/02/13/HelloWorld/"},{"title":"手机视角","text":"典型闲得没事做（有些奇妙的东西）","link":"/2019/07/11/PhoneView/"},{"title":"运算符优先级","text":"运算符优先级描述在计算表达式时执行运算的先后顺序。先执行较高优先级的运算，然后执行较低优先级的运算。例如，先执行乘和除，再执行加减运算。 运算符优先级表P.S.:从上到下，从左到右，优先级依次减弱。 .tg {border-collapse:collapse;border-spacing:0;border-color:#ccc;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:#ccc;color:#333;background-color:#fff;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-top-width:1px;border-bottom-width:1px;border-color:#ccc;color:#333;background-color:#f0f0f0;} .tg .tg-b6b5{font-family:Verdana, Geneva, sans-serif !important;;border-color:inherit;text-align:left} .tg .tg-30cg{font-weight:bold;font-family:\"Arial Black\", Gadget, sans-serif !important;;border-color:inherit;text-align:left;vertical-align:top} .tg .tg-kiyi{font-weight:bold;border-color:inherit;text-align:left} .tg .tg-3idj{font-weight:bold;font-family:\"Arial Black\", Gadget, sans-serif !important;;border-color:inherit;text-align:left} .tg .tg-93b8{font-family:\"Lucida Console\", Monaco, monospace !important;;border-color:inherit;text-align:left} .tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} .tg .tg-ha72{font-weight:bold;font-family:Verdana, Geneva, sans-serif !important;;border-color:inherit;text-align:left} .tg .tg-xldj{border-color:inherit;text-align:left} .tg .tg-5nj1{font-family:\"Lucida Console\", Monaco, monospace !important;;border-color:inherit;text-align:left;vertical-align:top} .tg .tg-r0kq{font-family:Verdana, Geneva, sans-serif !important;;border-color:inherit;text-align:left;vertical-align:top} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 优先级 运算符 说明 结合性 1 :: 范围解析 自左向右 2 ++ -- 后缀自增/后缀自减 () 括号 [] 数组下标 . 成员选择（对象） −&gt; 成员选择（指针） 3 ++ -- 前缀自增/前缀自减 自右向左 + − 加/减 ! ~ 逻辑非/按位取反 (type) 强制类型转换 * 取指针指向的值 &amp; 某某的地址 sizeof 某某的大小 new,new[] 动态内存分配/动态数组内存分配 delete,delete[] 动态内存释放/动态数组内存释放 4 .* -&gt;* 成员对象选择/成员指针选择 自左向右 5 * / % 乘法/除法/取余 6 + − 加号/减号 7 &lt;&lt; &gt;&gt; 位左移/位右移 8 &lt; &lt;= 小于/小于等于 &gt; &gt;= 大于/大于等于 9 == != 等于/不等于 10 &amp; 按位与 11 ^ 按位异或 12 | 按位或 13 &amp;&amp; 与运算 14 || 或运算 15 ?: 三目运算符 自右向左 16 = 赋值 += −= 相加后赋值/相减后赋值 *= /= %= 相乘后赋值/相除后赋值/取余后赋值 &lt;&lt;= &gt;&gt;= 位左移赋值/位右移赋值 &amp;= ^= |= 位与运算后赋值/位异或运算后赋值/位或运算后赋值 17 throw 抛出异常 18 , 逗号 自左向右 QAQ(打这个表格真心累)","link":"/2019/07/12/PriorityLevel/"},{"title":"bitset类","text":"bitset是一种类似数组的结构，包含于头文件bitset，它的每一个元素只能是$0$或$1$，每个元素仅占用$1\\space bit$的空间 构造函数举例如下 1234567891011121314bitset&lt;4&gt; b1; //无参构造，长度4，默认每一位为0bitset&lt;8&gt; b2(12); //值为12的二进制，长度8，前面用0补充string s=\"100101\"; //字符串内容只能是1或者0bitset&lt;10&gt; b3(s); //长度10 char str[]=\"10101\"; //同上bitset&lt;13&gt; b4(str); //长度13cout&lt;&lt;b1&lt;&lt;endl; //0000cout&lt;&lt;b2&lt;&lt;endl; //00001100cout&lt;&lt;b3&lt;&lt;endl; //0000100101cout&lt;&lt;b4&lt;&lt;endl; //0000000010101 构造时，需在&lt; &gt;中表明bitset的大小（$size$） 在进行有参构造时，若参数的二进制表示比$size$小，则在前面用$0$补充(如上)；若比bitsize大，参数为整数时取后面部分，参数为字符串时取前面部分(如下)： 1234567891011121314bitset&lt;2&gt; b1(12);//12的二进制(1100)长度为4，但b1的size=2，只取后面部分，即00string s=\"100101\";bitset&lt;4&gt; b2(s);//s的size=6，而bitset的size=4，只取前面部分，即1001char str[]=\"11101\";bitset&lt;4&gt; b3(str);//与b2同理，只取前面部分，即1110cout&lt;&lt;b1&lt;&lt;endl; //00cout&lt;&lt;b2&lt;&lt;endl; //1001cout&lt;&lt;b3&lt;&lt;endl; //1110 运算符1234567891011121314151617181920bitset&lt;4&gt; foo(string(\"1001\"));bitset&lt;4&gt; bar(string(\"0011\"));cout&lt;&lt;(foo^=bar)&lt;&lt;endl; //1010(foo对bar按位异或后赋值给foo)cout&lt;&lt;(foo&amp;=bar)&lt;&lt;endl; //0010(按位与后赋值给foo)cout&lt;&lt;(foo|=bar)&lt;&lt;endl; //0011(按位或后赋值给foo)cout&lt;&lt;(foo&lt;&lt;=2)&lt;&lt;endl; //1100(左移2位，低位补0，有自身赋值)cout&lt;&lt;(foo&gt;&gt;=1)&lt;&lt;endl; //0110(右移1位，高位补0，有自身赋值)cout&lt;&lt;(~bar)&lt;&lt;endl; //1100(按位取反)cout&lt;&lt;(bar&lt;&lt;1)&lt;&lt;endl; //0110(左移)cout&lt;&lt;(bar&gt;&gt;1)&lt;&lt;endl; //0001(右移)cout&lt;&lt;(foo==bar)&lt;&lt;endl; //false(0110==0011为false)cout&lt;&lt;(foo!=bar)&lt;&lt;endl; //true(0110!=0011为true)cout&lt;&lt;(foo&amp;bar)&lt;&lt;endl; //0010(按位与)cout&lt;&lt;(foo|bar)&lt;&lt;endl; //0111(按位或)cout&lt;&lt;(foo^bar)&lt;&lt;endl; //0101(按位异或) 除此之外，可以通过[ ]访问元素(类似数组)，最低位下标为$0$ 12345 bitset&lt;4&gt; foo (\"1011\"); cout&lt;&lt;foo[0]&lt;&lt;endl; //1cout&lt;&lt;foo[1]&lt;&lt;endl; //1cout&lt;&lt;foo[2]&lt;&lt;endl; //0 一些函数12345678910111213141516171819202122bitset&lt;8&gt; foo(\"10011011\");cout&lt;&lt;foo.count()&lt;&lt;endl;//5 count函数用来求bitset中1的位数，foo中共有5个1cout&lt;&lt;foo.size()&lt;&lt;endl;//8 size函数用来求bitset的大小，一共有8位cout&lt;&lt;foo.test(0)&lt;&lt;endl;//true test函数用来查下标处的元素是0还是1，并返回false或true，此处foo[0]为1，返回truecout&lt;&lt;foo.test(2)&lt;&lt;endl;//false 同理，foo[2]为0，返回falsecout&lt;&lt;foo.any()&lt;&lt;endl;//true any函数检查bitset中是否有1cout&lt;&lt;foo.none()&lt;&lt;endl;//false none函数检查bitset中是否没有1cout&lt;&lt;foo.all()&lt;&lt;endl;//false all函数检查bitset中是全部为1 test和[ ]的区别：test函数会对下标越界作出检查，而通过[ ]访问元素却不会经过下标检查，所以，在两种方式通用的情况下，选择test函数更安全一些 另一些函数：123456789101112131415161718192021222324252627282930bitset&lt;8&gt; foo(\"10011011\");cout&lt;&lt;foo.flip(2)&lt;&lt;endl;//10011111 flip函数传参数时，用于将参数位取反// 本行代码将foo下标2处取反，即0变1，1变0cout&lt;&lt;foo.flip()&lt;&lt;endl;//01100000 flip函数不指定参数时// 将bitset每一位全部取反cout&lt;&lt;foo.set()&lt;&lt;endl;//11111111 set函数不指定参数时// 将bitset的每一位全部置为1cout&lt;&lt;foo.set(3,0)&lt;&lt;endl;//11110111 set函数指定两位参数时// 将第一参数位的元素置为第二参数的值// 本行对foo的操作相当于foo[3]=0cout&lt;&lt;foo.set(3)&lt;&lt;endl;//11111111 set函数只有一个参数时// 将参数下标处置为1cout&lt;&lt;foo.reset(4)&lt;&lt;endl;//11101111 reset函数传一个参数时// 将参数下标处置为1cout&lt;&lt;foo.reset()&lt;&lt;endl;//00000000 reset函数不传参数时// 将bitset的每一位全部置为0 同样，它们也都会检查下标是否越界，如果越界就会抛出异常 最后，还有一些类型转换的函数： 1234567891011121314bitset&lt;8&gt;foo(\"10011011\");string s=foo.to_string();//将bitset转换成string类型unsigned long a=foo.to_ulong();//将bitset转换成unsigned long类型unsigned long long b=foo.to_ullong();//将bitset转换成unsigned long long类型cout&lt;&lt;s&lt;&lt;endl; //10011011cout&lt;&lt;a&lt;&lt;endl; //155cout&lt;&lt;b&lt;&lt;endl; //155 一些算法比较两个bitset的大小直接用大于小于号比较是明显不可取的（bitset连operator&gt;都没有，差评） 但to_ulong()函数给了蒟蒻我的一线生路 123456bool compare(bitset&lt;N&gt; a,bitset&lt;N&gt; b){ unsigned long ula=a.to_ulong(); unsigned long ulb=b.to_ulong(); return ula&gt;ulb;}","link":"/2019/07/24/bitset/"},{"title":"list类","text":"list介绍$list$是双向链表结构，它的数据由若干个节点构成，每一个节点都包括一个信息块（即实际存储的数据）、一个前驱指针和一个后驱指针。 特点 不能随机访问 插入或删除数据非常迅速 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521. assign() //给list赋值 2. back() //返回最后一个元素 3. begin() //返回指向第一个元素的迭代器 4. clear() //删除所有元素 5. empty() //如果list是空的则返回true 6. end() //返回末尾的迭代器 7. erase() //删除一个元素 8. front() //返回第一个元素 9. get_allocator() //返回list的配置器 10.insert() //插入一个元素到list中 11.max_size() //返回list能容纳的最大元素数量 12.merge() //合并两个list 13.pop_back() //删除最后一个元素 14.pop_front() //删除第一个元素 15.push_back() //在list的末尾添加一个元素 16.push_front() //在list的头部添加一个元素 17.rbegin() //返回指向第一个元素的逆向迭代器 18.remove() //从list删除元素 19.remove_if() //按指定条件删除元素 20.rend() //指向list末尾的逆向迭代器 21.resize() //改变list的大小 22.reverse() //把list的元素倒转 23.size() //返回list中的元素个数 24.sort() //给list排序 25.splice() //合并两个list 26.unique() //删除list中重复的元素 此文根据网络资源整理修改。","link":"/2019/02/13/list/"},{"title":"map类","text":"$map$是$STL$的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在$map$中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。$map$内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在$map$内部所有的数据都是有序的。 优点及功能 自动建立$key-value$（下表-值）的对应。$key$和$value$可以是任意需要的类型。 根据$key$值快速查找记录，查找的复杂度基本是Log(N)，如果有$1000$个记录，最多查找$10$次；$1,000,000$个记录，最多查找$20$次。 快速插入$Key$-$Value$ 记录。 快速删除记录 根据$key$修改$value$记录。 遍历所有记录。 声明头文件如下: 1#include&lt;map&gt; 声明$map$需要关键字和存储对象两个模板参数： 1std::map&lt;int,string&gt; m; 其中$int$为索引，$string$为存储对象 插入数据 用$insert$函数插入$pair$数据:123456789101112131415#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main(){ map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, \"student_one\")); mapStudent.insert(pair&lt;int, string&gt;(2, \"student_two\")); mapStudent.insert(pair&lt;int, string&gt;(3, \"student_three\")); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl; return 0;} 此文根据网络资源整理修改。 原文地址：这里 原文作者：$Boblim$","link":"/2019/02/13/map/"},{"title":"NOIP2018游记","text":"概述时间：$2018$年$11$月$10$日 等级：难受的普及组 得分：难受的二等奖，$180$分 $rank$：$3756$ 考试心态：心态是什么东西，没有 经历我是我们学校唯一一个初三还参加$NOIP$普及组的人(提高组还有一个人)，由此可得，$I$ $am$ $so$ $vegetable$. 初三，星期六学校还疯狂地上课，早自习刚上完，我就准备好上车了。可光是找校车就花了我好多时间。 校车开地是出奇地快慢。到了科大，已经中午了。 最开心的一点是遇到了许久未见的$QT$(长达$3$天未见)，他考提高组。 我打开题目文档，第一题把我看蒙了：[标题统计]，字符串不是我的强项，但由于题很简单，我花了$5$分钟写完代码，检查了$10$分钟(如果第一题丢分多可惜)，确认无误后再丢到$D$盘$noip$目录下。 第二题叫[龙虎斗]，仔细一看，是普普通通的模拟，但数据有点$crazy$，我又没想到“兵”只用去一边，却优化了半天的$IO$，$20$分用去喂$TLE$了。 第三题[摆渡车]，万恶的$DP$，我本来就不会$DP$，加上提议理解错，只得了$10$分。 这时，监考老师说： “同学们检查一下文件保存好没有，要收卷了！” 啥？？？刚打开第四题的我一脸懵。于是我开始蒙，题都没读。蒙的是输出$4$（事实证明，$4$是$0$分，$3$是$32$分$qwq$）。 总结这次考的不尽如人意，虽说有点运气的成分，但更多是我实力的欠缺，因此要加强$OI$的学习，争取提高一等。","link":"/2019/02/13/noip2018/"},{"title":"queue类","text":"基础了解$queue$类是$STL$的一个模板类,队列,是一种先进先出($FIFO$)的数据结构,读音和$Q$类似 $queue$包含在头文件$queue$中: 1#include&lt;queue&gt; 定义方式1queue&lt;int&gt; Q; 即 1queue&lt;operator&gt; name; 使用方法1234567891011121. Q.empty(); //返回队列是否为空2. Q.size(); //返回当前队列长度3. Q.front(); //返回当前队列的第一个元素4. Q.back(); //返回当前队列的最后一个元素5. Q.push(); //在队列后面插入一个元素, 比如插入数字5:Q.push(5)6. Q.pop(); //从当前队列里,移出第一个元素 代码示例12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;typedef queue&lt;int&gt; q_i;q_i Q;int main(){ cout&lt;&lt;\"Queue empty?\\t\"&lt;&lt;Q.empty()&lt;&lt;endl; for(int i=1;i&lt;=10;i++) Q.push(i);//入队 cout&lt;&lt;\"Queue empty?\\t\"&lt;&lt;Q.empty()&lt;&lt;endl; cout&lt;&lt;\"Queue size:\\t\"&lt;&lt;Q.size()&lt;&lt;endl; cout&lt;&lt;endl; //出队法遍历清空原数据 for(int i=1;i&lt;=10;i++) { cout&lt;&lt;\"Queue front:\\t\"&lt;&lt;Q.front()&lt;&lt;endl; Q.pop();//出队 } cout&lt;&lt;endl; cout&lt;&lt;\"Queue empty?\\t\"&lt;&lt;Q.empty()&lt;&lt;endl; return 0;} 输出 12345678910111213141516Queue empty? 1 //trueQueue empty? 0 //falseQueue size: 10Queue front: 1Queue front: 2Queue front: 3Queue front: 4Queue front: 5Queue front: 6Queue front: 7Queue front: 8Queue front: 9Queue front: 10Queue empty? 1 //true","link":"/2019/02/13/queue/"},{"title":"set类","text":"set介绍$set$的特性是，所有元素都会根据元素的键值自动排序，$set$的元素不像$map$那样可以同时拥有实值($value$)和键值($key$),$set$元素的键值就是实值，实值就是键值。$set$不允许两个元素有相同的键值(即不能重复，而$multiset$允许重复)。 建立方法包含$set$的头文件如下： 1#include&lt;set&gt; $set$类型名称：$set$&lt;$T$&gt;或是$set$&lt;$T$,$Ordering$&gt;，表明由$T$类型的元素构成的一个$set$，$Ordering$用于对元素进行排序，以便存储，如果没有指定，默认为小于。 迭代器：$iterator$、$const$$iterator$、$reverse$$iterator$、$const$$reverse$$iterator$，所有迭代器都是双向的，除了$const$_修饰的都是可变的，$begin()$、$end()$、$rbegin()$、$rend()$具有预期的行为，一般的增删元素不影响迭代器，除非定位的是要删除的元素。 常用方法12345678910111213141516171819202122232425262728291. s.insert() //将元素的一个副本插入set，不能重复插入相同的元素， //而set中的a和b重复：\"a必须排在b前面\"和\"b必须排在a前面\"都不成立 2. s.erase() //从set中删除元素，没有则没有任何效果 3. s.erase() //删除迭代器定位的位置处的元素4. s.find() //返回一个可变迭代器，它定位到set中的元素的一个副本，如果元素不在set中则返回s.end() 5. s.size() //返回set的元素数量 6. s.empty() //判断set是否为空 7. s1==s2 //如果set中包含相同的元素就返回true，否则返回false8. s.begin() //返回set的第一个元素9. s.end() //返回set的最后一个元素10.s.clear() //删除set中的所有的元素11.s.empty() //判断set是否为空12.s.max_size() //返回set可能包含的元素最大个数13.s.rbegin() //返回指向集合中最后一个元素的反向迭代器14.s.rend() //返回指向集合中第一个元素的反向迭代器 代码示例123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main(){ set&lt;char&gt; s; s.insert('A'); s.insert('D'); s.insert('D'); s.insert('C'); s.insert('C'); s.insert('B'); cout&lt;&lt;\"The set contains:\\n\"; set&lt;char&gt;::const_iterator p; for(p=s.begin();p!=s.end();p++) cout&lt;&lt;*p&lt;&lt;\" \"; cout&lt;&lt;endl; cout&lt;&lt;\"Removing C.\\n\"; s.erase('C'); for(p=s.begin();p!=s.end();p++) cout&lt;&lt;*p&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;} 输出： 1234The set contains:A B C DRemoving C.A B D","link":"/2019/02/13/set/"},{"title":"题解P1003[铺地毯]","text":"链接题目来源：$P1003$ 题目描述为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有$n$张地毯，编号从$1$到$n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。 地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入输出格式输入格式输入共$n+2$行 第一行，一个整数$n$，表示总共有$n$张地毯 接下来的$n$行中，第$i+1$行表示编号$i$的地毯的信息，包含四个正整数$a,b,g,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标$(a,b)$以及地毯在$x$轴和$y$轴方向的长度 第$n+2$行包含两个正整数$x$和$y$，表示所求的地面的点的坐标$(x,y)$ 输出格式输出共$1$行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出$−1$ 输入输出样例输入样例#11234531 0 2 30 2 3 32 1 3 32 2 输出样例#113 输入样例#21234531 0 2 30 2 3 32 1 3 34 5 输出样例#21-1 说明样例$1$解释如下图，$1$号地毯用实线表示，$2$号地毯用虚线表示，$3$号用双实线表示，覆盖点$(2,2)$的最上面一张地毯是$3$号地毯。 数据范围对于$30%$的数据，有$n≤2$ 对于$50%$的数据，$0≤a,b,g,k≤100$ 对于$100%$的数据，有$0≤n≤10,000$ ，$0≤a,b,g,k≤100,000$。 $NOIP2011$提高组$Day1$第$1$题 解答这道题，一般人会想到用二维数组来模拟地毯覆盖，如下： 1int m[MAX][MAX]; 但因为$0≤a,b,g,k≤100,000$，$MAX$必须设的很大，为$200002$，明显 超量程了(哦，对不起物理学多了) 会超内存限制。 所以进而容易想到判断题目给的要求的点是否在每个地毯范围内，我的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; a,b,lenx,leny;//用STL的vector存储,方便快捷int n,x,y,set=0;void cover(int);int main(){ cin&gt;&gt;n; int tmp;//用临时变量读入a,b,lenx,leny for(int i=0;i&lt;n;i++) { cin&gt;&gt;tmp; a.push_back(tmp); //push_back()是vector的追加命令 cin&gt;&gt;tmp; b.push_back(tmp); cin&gt;&gt;tmp; lenx.push_back(tmp); cin&gt;&gt;tmp; leny.push_back(tmp); } cin&gt;&gt;x&gt;&gt;y; for(int i=0;i&lt;n;i++)//依次判断是否覆盖 cover(i);//覆盖第i号地毯 if(set==0) cout&lt;&lt;-1;//别忘了这一步 else cout&lt;&lt;set; return 0;}void cover(int k){ int i=x-a[k],j=y-b[k]; if(i&gt;=0 &amp;&amp; i&lt;=lenx[k] &amp;&amp; j&gt;=0 &amp;&amp; j&lt;=leny[k]) set=k+1;//因为k是从0到n-1的，所以最后要加1}","link":"/2019/04/05/solution-p1003/"},{"title":"题解P1097[统计数字]","text":"链接题目来源：$P1097$ 题目描述某次科研调查时得到了$n$个自然数，每个数均不超过$1500000000(1.5\\times10^9)$。已知不相同的数不超过$10000$个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。 输入输出格式输入格式共$n+1$行。 第一行是整数$n$，表示自然数的个数； 第$2$至$n+1$每行一个自然数。 输出格式共$m$行（$m$为$n$个自然数中不相同数的个数），按照自然数从小到大的顺序输出。 每行输出$2$个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。 输入输出样例输入样例#11234567898242451002100 输出样例#112342 34 25 1100 2 说明$40%$的数据满足：$1≤n≤1000$ $80%$的数据满足：$1≤n≤50000$ $100%$的数据满足：$1≤n≤200000$，每个数均不超过$1500000000(1.5\\times10^9)$ $NOIP$ $2007$提高第一题 解答精通$STL$的人很容易会想到用神器$map$来存储，它相对于普通数组有如下优点： 默认按升序排序 对每一个数都有一个映射 简便，遍历方便 $\\dots$ 因为每个数均不超过$1.5\\times10^9$，所以大可以用$int$而不是$string$。 代码如下： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;//map必备的头文件using namespace std;typedef map&lt;int,int&gt; map_i;//太长一串太烦人int n;map_i m;int main(){ cin&gt;&gt;n; int tmp; for(int i=0;i&lt;n;i++) { cin&gt;&gt;tmp; m[tmp]++;//如果没有tmp，m会自动创建，其映射默认值为0 } for(map_i::iterator i=m.begin();i!=m.end();i++)//iterator是迭代器，用于遍历m { cout&lt;&lt;i-&gt;first&lt;&lt;\" \"&lt;&lt;i-&gt;second&lt;&lt;endl; //直接输出key和value即可 } return 0;}","link":"/2019/04/05/solution-p1097/"},{"title":"题解P1321[单词覆盖还原]","text":"链接题目来源：$P1321$ 题目描述在一长串($3\\leq l\\leq255$)中被反复贴有$boy$和$girl$两单词，后贴上的可能覆盖已贴上的单词(没有被覆盖的用句点表示)，最终每个单词至少有一个字符没有被覆盖。问贴有几个$boy$几个$girl$? 输入输出格式输入格式一行被被反复贴有$boy$和$girl$两单词的字符串。 输出格式两行，两个整数。第一行为$boy$的个数，第二行为$girl$的个数。 输入输出样例输入样例#11..boyogirlyy..girl... 输出样例#11242 解答仔细观察，$boy$和$girl$两词中没有重复的字母，并且题中说到字符串中只有$boy$、$girl$和句点，即只有以下字符： $b$,$o$,$y$,$g$,$i$,$r$,$l$,$.$ 但这不意味着直接统计非句点的字符数，因为每一个单词有可能不被遮完，如样例中分解如下： $boy$ $o$ $girl$ $y$ $y$ $girl$ 于是，我们可以把$boy$和$girl$中可能出现的重叠形式替换成某个字符(我用$a$替换$boy$的组合，用$z$替换$girl$的组合) 就可以得出这样的函数来替换： 1234567891011121314151617181920212223void replace_boy(char* sub,int len)//sub为boy可能的组合{ char *boy=strstr(str,sub); //strstr(str1,str2)函数在字符串str1中找str2并返回其首次出现的地址 while(boy!=NULL) { *boy='a';//替换为a for(int i=1;i&lt;len;i++) *(boy+i)='.';//后用句点替换 boy=strstr(str,sub);//找下一个符合的 }}void replace_girl(char* sub,int len)//本质上和replace_boy(char*,int)一样{ char *girl=strstr(str,sub); while(girl!=NULL) { *girl='z'; for(int i=1;i&lt;len;i++) *(girl+i)='.'; girl=strstr(str,sub); }} 可得出$boy$和$girl$有可能的组合如下： $boy$ $bo$ $oy$ $b$ $o$ $y$ $girl$ $gir$ $irl$ $gi$ $ir$ $rl$ $g$ $i$ $r$ $l$ 其中单个字母的($b$,$o$,$y$,$g$,$i$,$r$,$l$)可在判断$a$和$z$时一同判断 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;char str[260];void init();void replace_boy(char*,int);void replace_girl(char*,int);int main(){ cin&gt;&gt;str; init(); int boy=0,girl=0; for(int i=0,len=strlen(str);i&lt;len;i++) { if(str[i]=='a' || str[i]=='b' || str[i]=='o' || str[i]=='y') boy++; else if(str[i]=='z' || str[i]=='g' || str[i]=='i' || str[i]=='r' || str[i]=='l') girl++; } cout&lt;&lt;boy&lt;&lt;endl&lt;&lt;girl; cin.get();cin.get(); return 0;}void init(){ replace_boy(\"boy\",3); replace_boy(\"bo\",2); replace_boy(\"oy\",2); replace_girl(\"girl\",4); replace_girl(\"gir\",3); replace_girl(\"irl\",3); replace_girl(\"gi\",2); replace_girl(\"ir\",2); replace_girl(\"rl\",2); }void replace_boy(char* sub,int len){ char *boy=strstr(str,sub); while(boy!=NULL) { *boy='a'; for(int i=1;i&lt;len;i++) *(boy+i)='.'; boy=strstr(str,sub); }}void replace_girl(char* sub,int len){ char *girl=strstr(str,sub); while(girl!=NULL) { *girl='z'; for(int i=1;i&lt;len;i++) *(girl+i)='.'; girl=strstr(str,sub); }}","link":"/2019/05/12/solution-p1321/"},{"title":"题解P1125[笨小猴]","text":"链接题目来源：$P1125$ 题目描述笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！ 这种方法的具体描述如下：假设$maxn$是单词中出现次数最多的字母的出现次数，$minn$是单词中出现次数最少的字母的出现次数，如果$maxn-minn$是一个质数，那么笨小猴就认为这是个$Lucky Word$，这样的单词很可能就是正确的答案。 输入输出格式输入格式一个单词，其中只可能出现小写字母，并且长度小于$100$。 输出格式共两行，第一行是一个字符串，假设输入的的单词是$Lucky Word$，那么输出“Lucky Word”，否则输出“No Answer”；第二行是一个整数，如果输入单词是$Lucky Word$，输出$maxn-minn$的值，否则输出$0$。 输入输出样例输入样例#11error 输出样例#112Lucky Word2 输入样例#21olympic 输出样例#212No Answer0 解答在头文件$algorithm$中有这样的一个函数: 1count(...); 查询$MSDN$得:它的效果是取得一个范围中指定元素的多少。 假设有一个$string$字符串叫$s$，则取得$s$中字符‘$k$’的个数如下： 1count(&amp;s[0],&amp;s[s.length()],'k'); 其中$&amp;s[0]$为$s$的第一位元素的地址，$&amp;s[s.length()]$取$s$最后一个元素。若$s$内容为“$i$ $ak$ $noip,u$ $ak$ $ioi$”，则返回值为$2$。因此本题中直接枚举从$a$到$z$即可。 代码如下（已做防抄袭处理）： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;string word;//string真心好用int maxn=-1,minn=101;//保证能筛选出最大和最小void GetMaxMin(string);//取maxn和minnbool prime(int);int main(){ cin&gt;&gt;word; GetMaxMin(word); if(prime(maxn—minn)) cout&lt;&lt;\"Lucky Word\"&lt;&lt;endl&lt;&lt;maxn—minn; else cout&lt;&lt;\"No Answer\"&lt;&lt;endl&lt;&lt;\"O\"; return 0;//完美收官}void GetMaxMin(string s){ for(char c='a';c&lt;='z';c++)//暴力枚举 { int t=count(&amp;s[0],&amp;s[s.length()],c); maxn=max(t,maxn); if(t!=0)//重点，如果没这个字符，就不用谈最小值了 minn=min(t,minn); }}bool prime(int x){ if(x&lt;2)//如果小于2就不是质数 return false; for(int i=2;i&lt;=sqrt(x);i++) if(x%i==0) return false; return true;}","link":"/2019/02/13/solution-p1125/"},{"title":"题解P1781[宇宙总统]","text":"链接题目来源：$P1781$ 题目背景 宇宙总统竞选 题目描述地球历公元$6036$年，全宇宙准备竞选一个最贤能的人当总统，共有$n$个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。 输入输出格式输入格式：第一行为一个整数$n$,代表竞选总统的人数。 接下来有$n$行，分别为第一个候选人到第$n$个候选人的票数。 输出格式：共两行，第一行是一个整数$m$，为当上总统的人的号数。 第二行是当上总统的人的选票。 输入输出样例输入样例#112345659876512365879541022356985678 输出样例#11241022356 说明票数可能会很大，可能会到$100$位数字。 $n\\leqslant20$ 解答这个题，乍一看，我还以为是用高精… 相信很多人都会和我想的一样 实际上，只要好好想一想，就很容易想到$string$字符串的比较。 此解法核心：当当前输入和当前最大值字符串位数相同时，直接用$”&gt;”$比较，位数不同时，直接比位数(特别感谢@crab-in-the-northeast提醒) 我们用$maxs$来记录最大的票数，用$maxi$记录最大票数的排号，依次判断更新如下 1234567int tmplen=tmp.length();int maxslen=maxs.length();if((tmp&gt;maxs &amp;&amp; tmplen==maxslen) || tmplen&gt;maxslen){ maxs=tmp; maxi=i;} 完整的代码如下 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string tmp,maxs;int n,maxi=0;int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;tmp; int tmplen=tmp.length(); int maxslen=maxs.length(); if((tmp&gt;maxs &amp;&amp; tmplen==maxslen) || tmplen&gt;maxslen) { maxs=tmp; maxi=i; } } cout&lt;&lt;maxi&lt;&lt;endl&lt;&lt;maxs; return 0;}","link":"/2019/02/16/solution-p1781/"},{"title":"题解P3955[图书管理员]","text":"链接题目来源：$P3955$ 题目描述图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图 书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。小$D$刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他 需要的书，请输出$-1$。 输入输出格式输入格式第一行，包含两个正整数$n$,$q$，以一个空格分开，分别代表图书馆里书的数量和读者的数量。 接下来的$n$行，每行包含一个正整数，代表图书馆里某本书的图书编码。 接下来的$q$行，每行包含两个正整数，以一个空格分开，第一个正整数代表图书馆里读者的需求码的长度，第二个正整数代表读者的需求码。 输出格式$q$行，每行包含一个整数，如果存在第$i$个读者所需要的书，则在第$i$行输出第$i$个读者所需要的书中图书编码最小的那本书的图书编码，否则输出$−1$。 输入输出样例输入样例#112345678910115 5 2123 1123 23 24 24 2 23 3 123 3 124 2 12 2 12 输出样例#112345231123-1-1-1 说明【数据规模与约定】对于$20%$的数据，$1≤n≤2$。 另有$20%$的数据，$q=1$。 另有$20%$的数据，所有读者的需求码的长度均为$1$。 另有$20%$的数据，所有的图书编码按从小到大的顺序给出。 对于$100%$的数据，$1≤n≤1,000$,$1≤q≤1,000$，所有的图书编码和需求码均不超过$10,000,000$。 解答这道题，能想到$%$就赢一大半了 还记得当时我坐在考场的时候，看着各位神犇，我脑子里一片空白，像$memset(brain,0,sizeof(brain))$一样，胡乱地提交了一个答案…… 结果得了$10$分… 回来本蒟蒻闲的没事做，再看了一下，结合一些题解，做出了这个题 以下为变量的意思: 我们用$n$来表示$n$(没毛病),即书的数量 用$q$来表示读者数量 $length$表示需求码的长度 $need$表示读者需要的需求码 $mod$取出一本书的后几位 $get[]$为最后输出的最小图书编码 $book[]$为图书馆已有的书编码 输入先输入$n$和$q$: 1cin&gt;&gt;n&gt;&gt;q; 再循环输入图书馆有的书的编码: 12for(int i=0;i&lt;n;i++)//我喜欢从0开始 cin&gt;&gt;book[i]; $length$和$need$在$q$的循环中输入 主体循环内容 应为$get[i]$最后的只要最小,因此可以用”$&lt;$”判断，因此$get[i]$的初始值要最大那应该是多少呢?题中说需求码最大值为$10000000$,故$get[i]$设为$10000001$即可这个时候再输入$length$和$need$: 1cin&gt;&gt;length&gt;&gt;need; 重点用$mod$来取图书编码$book$的后$length$位,用$book[j]%mod$即可,$mod$初始化可以用$pow()$运算: 1mod=pow(10,length);//10的length次方 即 $$mod=10^{length}$$再依次遍历所以图书编码,进行判断(注意:要保证图书码比候选的大): 1234567for(int j=0;j&lt;n;j++){ //这里的%取得后面几个数字 //如果相等且为最小则进入候选 if(book[j]%mod==need &amp;&amp; book[j]&lt;get[i]) get[i]=book[j];} 填坑如果没有需求码满足,难不成直接输出$get[i]$即$10000001$吗?肯定不行,按题意要求，输出时再转换为$-1$ 完整代码1234567891011121314151617181920212223242526272829303132333435//图书管理员.cpp#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int n,q,length,need,mod,get[1010],book[1010];int main(){ //输入 cin&gt;&gt;n&gt;&gt;q; for(int i=0;i&lt;n;i++) cin&gt;&gt;book[i]; for(int i=0;i&lt;q;i++) { //初始置10000001，因为需求码最大值为10000000 //判断最小值 get[i]=10000001; cin&gt;&gt;length&gt;&gt;need;//在输入的同时判断，节省空间 mod=pow(10,length);//计算10的length次方 for(int j=0;j&lt;n;j++) { //这里的%取得后面几个数字 //如果相等且为最小则进入候选 //我看有些题解用sort排序，我觉得没必要 if(book[j]%mod==need &amp;&amp; book[j]&lt;get[i]) get[i]=book[j]; } if(get[i]==10000001) //这时候再换为-1 get[i]=-1; cout&lt;&lt;get[i]&lt;&lt;endl; //愉快地输出 } return 0;}","link":"/2019/02/13/solution-p3955/"},{"title":"vector类","text":"基础了解$vector$类是$STL$的一个模板类,是一个向量,可理解为可变长的数组 $vector$包含在头文件$vector$中: 1#include&lt;vector&gt; 定义方式如果要创建$int$型的$vector$对象,创建如下: 1vector&lt;int&gt; v; 模板如下($operator$类型的叫$name$的对象): 1vector&lt;operator&gt; name; 定义方法还有很多种: 12345671. vector&lt;int&gt; a(10); //定义了10个整型元素的向量，但没有给出初值，其值不确定2. vector&lt;int&gt; a(10,1); //定义了10个整型元素的向量,且每个元素的初值为13. vector&lt;int&gt; a(b); //用b向量来创建a向量，整体复制性赋值4. vector&lt;int&gt; a(b.begin(),b.begin()+3); //定义了a值为b中第0个(包含)到第2个(包含)元素5. int b[7]={1,2,1,6,5,9,8}; vector&lt;int&gt; a(b,b+7);//从数组中获得初值 使用方法用”$.$”运算符使用其方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445461. v.assign(a.begin(),a.begin()+4); //把向量a的前0~3位赋值给v2. v.assign(4,2); //使v只含4个元素，且每个元素为23. v.back(); //返回v的最后一个元素4. v.front(); //返回v的第一个元素5. v[i]; //返回v的第i个元素，当且仅当v[i]存在6. v.clear(); //清空v中的元素7. v.empty(); //判断v是否为空，空则返回ture,不空则返回false8. v.pop_back(); //删除v向量的最后一个元素9. v.erase(a.begin()+1,v.begin()+3); //删除v中第1个(从第0个算起)到第2个元素 //即删除的元素从v.begin()+1算起(包括)一直到v.begin()+3(不包括)10.v.push_back(5); //在v的最后一个向量后插入一个元素，其值为511.v.insert(v.begin()+1,5); //在v的第1个元素的位置插入数值5 //如v为1,2,3,4,插入元素后为1,5,2,3,412.v.insert(v.begin()+1,3,5); //在v的第1个元素的位置插入3个数,其值都为513.v.insert(v.begin()+1,b+3,b+6); //数组b,在v的第1个元素的位置插入b的第3个元素到第5个元素(不包括b+6) //如b为1,2,3,4,5,9,8,插入元素后为1,4,5,9,2,3,4,5,9,814.v.size(); //返回v中元素的个数15.v.capacity(); //返回v在内存中总共可以容纳的元素个数16.v.resize(10); //将v的现有元素个数调至10个,多则删,少则补,其值随机17.v.resize(10,2); //将v的现有元素个数调至10个,多则删,少则补,其值为218.v.reserve(100); //将v的容量(capacity)扩充至100 //也就是说现在测试v.capacity();的时候返回值是100 //这种操作只有在需要给v添加大量数据的时候才显得有意义 //因为这将避免内存多次容量扩充操作(当v的容量不足时电脑会自动扩容，当然这必然降低性能)19.v.swap(b); //将v中的元素和向量b中的元素进行整体性交换20.v==b; //b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt; 实例常用功能示范12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;vector&gt; using namespace std;typedef vector&lt;int&gt; v_i;v_i v;int main(){ for(int i=1;i&lt;=100;i++) v.push_back(i); //初始化 cout&lt;&lt;\"Size:\\t\\t\"&lt;&lt;v.size()&lt;&lt;endl; //大小 cout&lt;&lt;\"87th:\\t\\t\"&lt;&lt;v[87]&lt;&lt;endl; //索引为87的值 cout&lt;&lt;\"Last:\\t\\t\"&lt;&lt;v.back()&lt;&lt;endl; //最后的值 cout&lt;&lt;\"First:\\t\\t\"&lt;&lt;v.front()&lt;&lt;endl;//第一个值 cout&lt;&lt;\"Use iterator:\"&lt;&lt;endl; //用iterator遍历 for(v_i::iterator ite=v.begin();ite&lt;v.end();ite++) cout&lt;&lt;*ite&lt;&lt;\" \"; cout&lt;&lt;endl&lt;&lt;\"done.\"; return 0;} 运行结果 12345678Size: 10087th: 88//注意这里不是87,第一个元素索引为0Last: 100First: 1Use iterator:1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100done.","link":"/2019/02/13/vector/"},{"title":"用hexo和GitHub搭建个人博客","text":"前言 由于版本更新缘故，$2018$年及以前的$hexo$博客搭建教程都对当前不适用，为了防止误导想搭建个人博客的小白，我总结并修改了网上部分搭建教程，如有不当请联系我，谢谢！ 推荐为了方便搭建个人博客，我推荐如下软件: $VScode$:可以当作方便的$markdown$编辑器(功能不止这一个)，但启动速度慢 $notepad++$:轻量级编辑器，对不同编程语言有不同颜色的区分，启动速度快 $chrome$:在设计过程中预览效果较快 搭建$GitHub$仓库注册$GitHub$ $GitHub$是一个面向开源及私有软件项目的托管平台，官网地址，因为只支持git作为唯一的版本库格式进行托管，故名$GitHub$。 注册$GitHub$仓库用于存储你的博客，其实还可以用其他仓库，我还是推荐用$GitHub$。 注册过程很简单，我草草过一下(我创建名为$waterdrop100$的账号用于演示)。 注册后还需要验证，它会给你的邮箱发一个链接，打开链接完成验证。 创建仓库 注册好后，单击左边提示栏的”$Create$ $a$ $repository$”，创建仓库。 在”$Repository$ $name$”栏里按用户名.github.io的格式填入，比如我应该填waterdrop100.github.io。 其他的不用填，直接点”$Create$ $repository$”，$GitHub$仓库创建完成！等待半个小时仓库才会生效。 搭建环境下载$node.js$和$git$ 下载链接:$node.js$,$git$。 $node.js$和$git$的安装很简单，网上资料很多，我就不多赘述了。 最好验证一下安装是否成功。打开$cmd$，输入node -v、npm -v和git --version，若输出正常则配置成功。 安装$hexo$ 找一个你觉得安全好的地方新建文件夹用于存储本地博客，最好不要在系统盘($C$盘)建。我再E盘建了一个$blog$文件夹，再用$cmd$进入。 再输入npm install hexo -g安装$hexo$，前面会有$3$个$WARN$不用管他(我也不知道是干嘛的)。 输入hexo -v，若输出版本信息，则安装成功。输入hexo init初始化文件夹(慢慢等)。 输入npm install安装插件. 它的警告一样的不管(求大神告诉我到底是什么意思……)。至此$hexo$安装完毕。 体验$hexo$ 如果你想看一下成果，那继续往下看。 输入hexo g更新文件，再输入hexo s开启本地测试用服务器。 在浏览器中输入网址http://localhost:4000预览你的博客！页面默认如下($hexo$默认创建了名为Hello World的文章) 连接$hexo$和$GitHub$设置$git$用户名和邮箱 在博客目录(我的是$E:/blog$)右键，选择Git Bash Here，输入git config --global user.name &quot;你注册GitHub的用户名&quot;，设置$git$的用户名。 输入git config --global user.email &quot;你注册GitHub的邮箱&quot;，设置$git$的邮箱。 配置$ssh$ 采用$ssh$加密传输，防止信息被窃。 下面的教程适用于用户目录下没有$.ssh$文件夹的人，如果有且有3个文件($id_rsa$、$id_rsa.pub$和$known_hosts$)，则可以直接跳过此节。 在$git$中输入ssh-keygen -t rsa -C &quot;你的邮箱&quot;，显示如下 输入eval &quot;$(ssh-agent -s)&quot;将密钥添加到$ssh-agent$。 再输入ssh-add ~/.ssh/id_rsa(我不知道是干啥用的，这样输就对了…)。 打开$GitHub$，单击头像，选择settings，再选择SSH and GPG keys 选择New SSH key，新建$ssh key$，粘贴用户目录下$.ssh$文件夹中$id_rsa.pub$文件的内容。 在$git$中输入ssh -T git@github.com，输入yes，若显示大概如下，则标准$ssh$配置成功。 配置$_config.yml$ 在博客文件夹中有一个文件叫_config.yml，它是博客核心配置，用编辑器打开，在文件末尾有如下内容。 将其修改为如下格式(注意，在每一个”$:$”后都必须有一个空格) 1234deploy: type: git repository: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git branch: master 其中repository一项是$GitHub$仓库页面的$ssh$地址。 完成连接 现在$GitHub$和本地文件夹已经连接好了，下面讲解本地上传到$GitHub$的方法 打开$cmd$，安装扩展:npm install hexo-deployer-git --save。 先hexo clean清一下缓存。 输入hexo d -g生成$+$部署，这个命令很重要，以后每次对博客有更改都要上传部署。 等个几分钟，你的网页就可以访问了，地址是GitHub用户名.github.io，比如我的是waterdrop100.github.io。 发布文章 有了博客还不会发布文章怎么行呢，下面来讲如何发布文章。文章一般在主页显示，就是你日常写博客的文章啦！ 在cmd中输入hexo new 文章名就会在source\\_posts目录下创建一个名为文章名.md的文件，推荐用$VScode$打开，用$markdown$继续编辑。 打开文件后，可以在右上角选择继续预览编辑。在文件开头有如下几行字: 12345---title: article //文章名date: 2019-02-21 07:32:26 //创建时间tags: //标签--- 这些是此文章的配置，后面可以增添删改一些内容。 配置文件 前面说过$_config.yml$是重要的配置文件，下面对其内容进行讲解(暂时不必更改)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 字前面加\"#\"的是注释# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo # 网站主标题，可改subtitle: # 网站副标题，可改description: # 站点描述keywords: # 在搜索引擎搜索到的关键词author: John Doe # 博主名字，可改language: # 语言timezone: # 时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com # 站点地址root: / # 主页位置permalink: :year/:month/:day/:title/ # 日期显示方式permalink_defaults:# Directory# 以下内容默认即可source_dir: source public_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # 新文章的名称default_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # 在新页面打开第三方链接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: # 高亮 enable: true #是否启用 line_number: true # 行号 auto_detect: false # 自动检测代码语言 tab_replace: # 替换Tab # 主页设置# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# 日期/时间格式化## Hexo用Moment.js插件来分析和显示日期## 可以使用在以下网站定义的格式化类型## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期类型time_format: HH:mm:ss # 时间类型# 分页设置## 把per_page设置成0来关闭分页per_page: 10 # 每页显示文章数量pagination_dir: page# 扩展## 插件下载地址: https://hexo.io/plugins/## 主题下载地址: https://hexo.io/themes/theme: landscape # 主题默认是landscape，后面教如何修改# 部署## 文档教程: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:waterdrop100/waterdrop100.github.io.git branch: master 小结 经过一番折腾，你的博客终于配置好了，但默认的页面不是很好看，下一篇文章讲解进一步的美化，让你的博客更个性化！ 我的博客:xecades.github.io，欢迎访问！ 编辑此文章我查阅的资料: https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.jianshu.com/p/9f0e90cc32c2 https://www.jianshu.com/p/21c94eb7bcd1","link":"/2019/02/22/BuildBlog/"},{"title":"数论-OwO的讲课笔记","text":"数论的笔记(写上博客是为了方便查阅) 打算以后加上密码 厄拉多塞筛法筛法的实现朴素的实现从小到大枚举$x$，将$x$的倍数标记为合数(很朴素对吧) 时间复杂度(调和级数): $$\\sum^n_{x=2}\\lfloor\\frac{n}{m}\\rfloor\\leq n\\sum^n_{x=1}\\frac{1}{x}=\\Theta(n\\ln n)$$ 不朴素的实现还是从小到大枚举$x$，若$x$是质数，则将$x$的倍数标记为合数 时间复杂度(梅滕斯第二定理): $$\\sum^n_{p\\in \\mathbb{P}}\\lfloor\\frac{n}{p}\\leq n\\sum^n_{p\\in\\mathbb{P}}\\frac{1}{p}=\\Theta(n\\ln\\ln n)$$ 优化实现从小到大枚举$x$，再从小到大枚举素数$p$，将$px$标记为合数，直到$p\\space|\\space x$ 因此，每个合数只会被其最小质因子筛去，则时间复杂度为: $$\\Theta(n)$$ 难道只能筛素数?筛法还可以用来预处理其他东西。 求每个数的最小素因子:线性筛时记录每个数被那个质数筛去 求每个数的最大素因子:线性筛时记录$f[x]$表示$x$的最小素因子，$f[p]:=p$，$f[px]:=f[x]$ 求积性函数的值 $\\dots\\dots$ 例题$\\mathtt{SPOJ\\space PRIME1:\\space Prime\\space Generator}$ 求出值域再$[L,R]$中的所有素数 $1\\leq L\\leq R\\leq 10^{14},\\space R-L+1\\leq 10^6$ 一个合数$n$的最小素因子$p$必然有$p\\leq\\sqrt n$。 先线性筛求出$\\sqrt R$中的所有质数， 再枚举每一个质数$p$，将$[L,R]$中$p$的倍数标记为合数。 时间复杂度： $$\\Theta(\\sqrt R+(R-L+1)\\ln\\ln R)$$ 与$\\gcd$有关的算法最大公约数对于两个正整数$a,b$，存在最大的正整数$d$满足$d\\space|\\space a$且$d\\space|\\space b$，则称$d$是$a,b$的最大公约数，记作: $$\\gcd(a,b)=d$$ 贝祖定理关于$x,y$的方程$ax+by=c$有解当且仅当$\\gcd(a,b)\\space|\\space c$ 欧几里得算法由贝祖定理可以推出 $$\\gcd(a,b)=\\gcd(b,a-b)$$ 由推论反复执行减法可得 $$\\gcd(a,b)=\\gcd(b,a\\mod b)$$ 反复迭代，直到$a=0$或$b=0$ 不妨设$a\\geq b$，可以证明迭代次数上限为$\\Theta(\\log_\\varnothing a)$，其中$\\varnothing=(\\sqrt5+1)/2$ 扩展欧几里得算法求$ax=by=\\gcd(a,b)$的一组解求$ax=by=\\gcd(a,b)$的一组解，可以用扩展欧几里得算法。 设$(x’,y’)$是$bx’+(a\\mod b)y’=\\gcd(a,b)$的一组解。 注意到 $$a\\mod b=a-b\\lfloor a/b\\rfloor$$ 对上式变形得到 时间复杂度同欧几里得算法，也是$\\Theta(\\log_\\varnothing a)$ 令$d:=\\gcd(a,b)$ 如果要求$ax+by=c$的解，有贝祖定理$d\\space|\\space c$，将扩展欧几里得算法得到的解乘$c/d$即可 求通解上面求出来的只是$ax+by=c$的一组通解$(x_0,y_0)$ 要想求通解，可以设$x=x_0+s$，$y=y_0-t$，代入原方程得 $$as=bt$$ 即 $$s=\\frac{b}{a}t=\\frac{b/d}{a/d}t$$ 也就是说通解为 同余若$a,b$ 膜 模$m$的余数相同，则称$a$和$b$模$m$同于，记为 $$a\\equiv b(\\mod m)$$ $a\\equiv b(\\mod m)$的充要条件是$m\\space|\\space a-b$。 若$a\\equiv b(\\mod m)$，则 $a\\pm c\\equiv b\\pm c(\\mod m)$ $ac\\equiv bc(\\mod m)$ 若$c\\space|\\space a$，$c\\space|\\space b$，则$a/c\\equiv b/c(\\mod m/gcd(m,c))$ 同余方程形如$a\\equiv b(\\mod m)$的方程称为同余方程。 根据同余的定义，同余方程等价于$ax+mt=b(t\\in\\mathbb Z)$，可以用扩展欧几里得算法求解。 同余方程有解的条件是$\\gcd(a,m)\\space|\\space b$。 例题$\\mathtt{NOI2002:\\space Savage}$ 有$N$个野人，第$i$个野人剩余寿命为$A_i$。有若干个山洞，山洞排成环形。初始时第$i$个野人住在山洞$C_i$，每一年第$i$个野人会顺时针走$P_i$个山洞然后住下来。求最少需要有多少个山洞才能使任意两个野人都不会在有生之年住在同一个洞穴 $N\\leq15$，答案不会超过$10^6$。 范围很小，枚举答案$M$然后判断。 枚举哪两个野人$i,j$碰面，求出碰面的最小时间， 与$\\min{A_i,A_j}$比较一下 $$C_i+P_ix\\equiv c_j+P_jx(\\mod M)$$ 逆元给定正整数$a$，若$\\exists x$满足$ax\\equiv 1(\\mod m)$，则称$x$是$a$在模$m$下的逆元，记为$a^{-1}$。 由同余方程可知，逆元存在的条件是$\\gcd(a,m)=1$。 用反证法可以证明，逆元若存在则唯一。 可以在$\\Theta(n)$内求出$1$到$n$的所有数模素数$p$的逆元，要求$n&lt;p$。 首先$1^{-1}=1$。 对于一个数$x(x&gt;1)$，设$p=ax+b$， 即$a=\\lfloor p/x\\rfloor$，$b=p\\mod x$。 有 $$ax+b\\equiv0(\\mod p)$$ 两边同时乘以$b^{-1}x^{-1}$，得 $$ab^{-1}+x^{-1}\\equiv0(\\mod p)$$ 即 $$x^{-1}\\equiv -ab^{-1}\\equiv -\\lfloor p/x\\rfloor(p\\mod x)^{-1}(\\mod p)$$ 因为$p\\mod x&lt;x$，所以其逆元已经算过了，可以按$x$从小到大的顺序递推。 同余方程组 设 $$x=k_1m_1+a_1=k_2m_2+a_2$$ 用扩展欧几里得算法可以求出一组$(k_1,k_2)$，即可求出$x$。 可以证明解在模$\\mathbf{lcm}(m_1,m_2)$意义下唯一存在（可以用后文的中国剩余定理推出）。 有多少个方程呢？注意到上面的过程实际上是将两个方程合并为了一个模$\\mathbf{lcm}(m_1,m_2)$的方程。多个方程依次合并即可。 中国剩余定理设$m_1,m_2,\\dots,m_n$两两互质，则同余方程组 在模$M=\\prod m_i$下有唯一解 $$x\\equiv\\sum a_i t_i M_i(\\mod M)$$ 其中$M_i=M/m_i$，$t_i$为$M_i$在模$m_i$下的逆元。 约数将$n$质因数分解 $$n=\\prod p_i^{r_i}$$ 约数个数 $$\\sigma_0(n)=\\prod(1+r_i)$$ 约数和 $$\\sigma_1(n)=\\prod\\sum^{r_i}_{k=0}p_i^k$$ 约数函数 $$\\sigma_t(n)=\\sum_{d\\space|\\space n}d^t=\\prod\\sum^{r_i}_{k=0}p_i^{kt}$$ 不大于$\\sqrt n$的约数不超过$\\lfloor\\sqrt n\\rfloor$个，大于$\\sqrt n$的约数$d$唯一对应一个小于$\\sqrt n$的约数$n/d$，也不超过$\\lfloor\\sqrt n\\rfloor$个，所以约数个数的上界是$\\Theta(\\sqrt n)$。 随机数据下，约数个数的期望是$\\Theta(\\ln n)$。 例题$\\mathtt{AHOI2007: 密码箱}$ 给定正整数$n$，求$[0,n-1]$中，所有满足$x^2\\equiv1(\\mod n)$的$x$。 $2\\leq n\\leq2\\times10^9$。 变形可得$(x-1)(x+1)\\equiv0(\\mod n)$，即$(x-1)(x+1)=kn$。 可以将$n$分解为$n=n_1n_2$，要么$x-1\\space|\\space n_1$且$x+1\\space|\\space n_2$，要么$x+1\\space|\\space n_1$且$x-1\\space|\\space n_2$。 不妨设$n_1\\leq n_2$，那么$n_1\\leq\\sqrt n$，$n_2\\geq\\sqrt n$。 $\\Theta(\\sqrt n)$枚举$n_1$，得到$n_2=\\frac{n}{n_1}$，再枚举$n_2$的倍数判断即可。 注意到枚举$n_2$的次数是$n_1$，所以时间复杂度为不超过$\\sqrt n$的约束和，看起来上界是$\\Theta(n)$，但因为约数很少，所以复杂度远不到上界，可以通过。","link":"/2019/07/30/NumberTheory/"},{"title":"矩阵乘法","text":"一个$m×n$的矩阵就是$m×n$个数排成$m$行$n$列的一个数阵。矩阵可以用于批量解决一些线性问题，例如递推方程。 另，$1\\times m$的矩阵又叫做向量(没错就是$vector$) 啥是矩阵乘法蒟阵乘法，顾名思义，就是两个矩阵(蒟蒻)乘起来，不过和普通的乘法不一样。 A.两个矩阵能相乘的条件当一个矩阵的行数等于另一个矩阵的列数时，两个相乘才有意义。 B.矩阵咋相乘三个矩阵$a,b,c$ 如果$a$等于$bc$的乘积，那么写作$a=bc$ 假设$b,c$都是$n\\times n$的矩阵，那么有 $$a_{ij}=\\sum^n_{k=1}b_{ik}\\times c_{kj}$$ 写成矩阵的形式就是 $$\\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}\\begin{bmatrix} e &amp; f \\\\ g &amp; h \\end{bmatrix}=\\begin{bmatrix} a\\times e+b\\times g &amp; a\\times f+b\\times h \\\\ c\\times e+d\\times g &amp; c\\times f+d\\times h\\end{bmatrix}$$ 这也就是为什么必须要求一个矩阵的行数等于另一个矩阵的列数，否则元素数不相等 C.注意事项如果两个大小为$a\\times n,n\\times m$的矩阵相乘,最后乘出来的矩阵就是是$a\\times m$的 而矩阵乘法的次数就是$a\\times n\\times m$ 例如$2\\times 3$和$3\\times 2$的矩阵相乘 $$\\left[\\begin{array}{lll}{1} &amp; {2} &amp; {3} \\\\ {4} &amp; {5} &amp; {6}\\end{array}\\right]\\left[\\begin{array}{ll}{1} &amp; {4} \\\\ {2} &amp; {5} \\\\ {3} &amp; {6}\\end{array}\\right]=\\left[\\begin{array}{lll}{1 \\times 1+2 \\times 2+3} &amp; {1 \\times 4+2 \\times 5+3+3+3} \\\\ {4 \\times 1+5 \\times 2+6 \\times 3} &amp; {4 \\times 4+5 \\times 5+6 \\times 6}\\end{array}\\right]$$ 如果问原因的话，我们可以发现，新矩阵的行数和左边矩阵的行数相等，而新矩阵的列数和后边矩阵的列数相等。 D.这东西有啥性质啊 矩阵乘法满足结合律，即$a(bc)=(ab)c$，可以通过这个性质减少乘法次数 而且，矩阵乘法没有交换律因为普通的加法和乘法满足交换律的原因是因为加法和乘法的结果都只是一个数,而矩阵的本质是数的排列,所以运算结果还是矩阵，并不是一个数，自然和数有区别 矩阵的单位元…这东西也不知道放在哪，就写这吧。 $\\left[\\begin{array}{lll}{1} &amp; {0} &amp; {0} \\\\ {0} &amp; {1} &amp; {0} \\\\ {0} &amp; {0} &amp; {1}\\end{array}\\right]$就是对角线上全为1 这玩意有啥用我咋知道啊 在某些题中可以加速递推公式，可以把一个$O(n)$的式子优化到$O(logn)$ 应用前提：矩阵快速幂(这又是啥啊)因为矩阵的乘法也有结合律，所以也可以用快速幂加速，也是矩阵优化递推的原理，即把一个不能用快速幂优化的式子转换成快速幂的形式 来个栗子啊出门左转炒锅 $$f(n) = f(n-1) + f(n-2) (n\\geq 2且n\\in\\mathbb{Z})$$ 请你求出$f(n)\\mod10^9+7$的值($n$在$longlong$($INT64$)范围内)。 显然线性爆炸，所以考虑加速。那么很容易想到矩阵乘法(我也不会别的) 那么考虑把这个递推式子变成可以矩阵的形式，那么就考虑把答案弄进一个矩阵里，(那么就设一个$1\\times 1$的吧！(啪)) 显然，设一个$1\\times 1$的矩阵是一个很不明智的行为，因为没法转移。考虑到当前的状态与前两项有关。 所以构造一个$1\\times 2$向量表示$\\begin{bmatrix}F_n &amp; F_{n-1}\\end{bmatrix}$ 那么转移也就很显然了 我们要达到这样一个目的： $$\\begin{bmatrix}F_{n-1} &amp; F_{n-2}\\end{bmatrix}\\rightarrow\\begin{bmatrix}F_n &amp; F_{n-1}\\end{bmatrix}$$ 变个形 $$\\begin{bmatrix}F_{n-1} &amp; F_{n-2}\\end{bmatrix}\\rightarrow\\begin{bmatrix}F_{n-1}\\times 1+F_{n-2}\\times 1 &amp; F_{n-1}\\times 1\\end{bmatrix}$$ 那么就可以构造中间的矩阵了 显然就是 $$\\begin{bmatrix}1 &amp; 1 \\\\ 1 &amp; 0\\end{bmatrix}$$ 带回去验证一下$qwq$ $$\\begin{bmatrix}F_n &amp; F_{n-1}\\end{bmatrix}\\begin{bmatrix}1 &amp; 1 \\\\ 1 &amp; 0\\end{bmatrix}=\\begin{bmatrix}F_{n-1}\\times 1+F_n\\times 1 &amp; F_{n}\\times 1+F_{n-1}\\times 0\\end{bmatrix}=\\begin{bmatrix}F_{n+1} &amp; F_{n}\\end{bmatrix}$$ 发现成立了诶。 更大的栗子出门右转大炒锅 广义的斐波那契数列是指形如$a_n=p\\times a_{n-1}+q\\times a_{n-2}$的式子，给出$p,q,a_1,a_2,n,m$，求$a_n\\mod m$。 除了和上一题的系数不变没区别啊喂(#`O′)(啪，多嘴) 考虑到只有转移时的系数变了，那么只要改变你构造的矩阵就可以了，那么我们再考虑转移是如何进行的 $$\\begin{bmatrix}F_n &amp; F_{n-1}\\end{bmatrix}\\begin{bmatrix}1 &amp; 1 \\\\ 1 &amp; 0\\end{bmatrix}=\\begin{bmatrix}F_{n-1}\\times 1+F_n\\times 1 &amp; F_{n}\\times 1+F_{n-1}\\times 0\\end{bmatrix}=\\begin{bmatrix}F_{n+1} &amp; F_{n}\\end{bmatrix}$$ 那么注意到改变的实际上只有这一项$F_{n-1}\\times 1+F_n\\times 1$，考虑这一项是怎么来的，根据矩阵乘法的定义我们知道这一项实际上是 向量的第一行乘矩阵的第一列，也就是$\\begin{bmatrix}F_n &amp; F_{n-1}\\end{bmatrix}\\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$ 那么我们只需要改动这一列即可，即把这一列改为$\\begin{bmatrix}p \\\\ q\\end{bmatrix}$ 那么最后的转移矩阵就是 $$\\begin{bmatrix}p &amp; 1 \\\\ q &amp; 0\\end{bmatrix}$$ 最后放上这个题的核心代码 12345678910111213141516ll mod;struct mar{ ll a[4][4];}ans,base;mar mul(mar x,mar y){ mar t; memset(t.a,0,sizeof(t.a)); for(int i=1;i&lt;=2;++i) for(int j=1;j&lt;=2;++j) for(int k=1;k&lt;=2;++k) t.a[i][j]+=(x.a[i][k])%mod*(y.a[k][j])%mod,t.a[i][j]%=mod; return t;} 12345ans.a[1][1]=a2,ans.a[1][2]=a1;base.a[1][2]=1;base.a[2][1]=q;base.a[1][1]=p;ksm(n-2); 关于矩阵乘法的优化A.缓存优化先普及一点知识: $CPU\\space cache$ 通俗点说就是平时说的缓存，是位于$CPU$和内存之间的临时存储器，具有体积小，交换速率快的特点，存储的是$CPU$即将访问的内存。 所以缓存存在的意义就是为了加快内存访问的速度。 那么对于$OIer$来说，这东西唯一的用处就是卡常，可能会有人听过”数组不要开偶偶数大小”之类的玄学。但这可能真的是有用的。 程序在一段时间内访问的数据通常具有局部性，比如对一维数组来说，访问了地址x上的元素，那么以后访问地址$x+1$、$x+2$上元素的可能性就比较高；这也称为$cache$的空间局限性。 如果说人话的话。就是数组的访问顺序是水平连续的。 让我们再来两个栗子 1 1234for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) for(int k=1;k&lt;=n;++k) c[i][j]=a[i][k]*b[k][j]; 2 1234for(int i=1;i&lt;=n;++i) for(int k=1;k&lt;=n;++k) for(int j=1;j&lt;=n;++j) c[i][j]=a[i][k]*b[k][j]; 眼尖的同学可能会发现，这两段程序唯一的不同只有二三层的循环循顺序啊(#`O′)(啪，就你多嘴) 那么实际上的效率可能会在数据很大的时候产生极大的差异。 因为根据我们上边所了解到的信息，对于代码2中的$a[i]$和$b[k]$这两行的访问都是连续的，所以缓存会被充分利用。这样就达到了卡常的目的。 这种做法的术语是$loop\\space permutation$(循环置换) 测试代码（搬运的时候图片丢了，凑合着看吧） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stack&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout);using namespace std;char IN[1&lt;&lt;17],*SS=IN,*TT=IN;inline char gc(){return (SS==TT&amp;&amp;(TT=(SS=IN)+fread(IN,1,1&lt;&lt;17,stdin),SS==TT)?EOF:*SS++);}inline int read(){ int now=0,f=1;register char c=gc(); for(;!isdigit(c);c=='-'&amp;&amp;(f=-1),c=gc()); for(;isdigit(c);now=now*10+c-'0',c=gc()); return now*f;}const int mod=1e9+7;long long a[1100][1100];long long temp[1010][1010];long long b[1010][1010];long long c[1010][1010];int main(){ freopen(\"a.out\",\"r\",stdin); freopen(\"x1.out\",\"w\",stdout); int n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j)b[i][j]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j)c[i][j]=read(); for(int i=1;i&lt;=n;++i) for(int k=1;k&lt;=n;++k) for(int j=1;j&lt;=n;++j) (a[i][j]+=b[i][k]*c[k][j])%=mod; // for(int i=1;i&lt;=n;++i) // for(int j=1;j&lt;=n;++j) // for(int k=1;k&lt;=n;++k) // (a[i][j]+=(b[i][k]*c[k][j]))%=mod; for(int i=1;i&lt;=n;++i)printf(\"%lld \",a[5][i]); printf(\"\\n\"); printf(\"Elapsed time:%.2lf secs.\\n\",1.0*clock()/1000.0); return 0;} 有兴趣的同学可以去尝试做一下$HUD4920$。 经典的矩阵乘法卡$(du)$常$(liu)$题。 B.矩阵分块当矩阵特别大时，可能会发生缓存放不下的情况，那么之前的$ikj$优化就会收效甚微，所以我们考虑把一个矩阵分为几块子矩阵，不过需要注意的是A的行的划分与B的列的划分必须一致。 12345678int size=n/25;for(int it=1;it&lt;=n;it+=size)for(int jt=1;jt&lt;=n;jt+=size)for(int kt=1;kt&lt;=n;kt+=size) for(int i=it;i&lt;=it+size;i++) for(int j=jt;j&lt;=jt+size;j++) for(int k=kt;k&lt;=kt+size;k++) (a[i][j]+=b[i][k]*c[k][j])%=mod; C.次数优化大家可能做过最优矩阵链乘问题问题。 本质就是利用结合律来减少乘法次数。 例如 A是一个$50×10$的矩阵，B是$10×20$的矩阵，C是$20×5$的矩阵 那么要把$ABC$乘起来的话，有两种顺序，一种是$(A(BC))$，另一种是$((AB)C)$ 而这两种顺序的乘法次数一个是$3500$次，而另一个却是$15000$次,所以当数据非常大的时候，我们可以考虑构造一个乘法的顺序，使得乘法次数最小，但只适用于矩阵少而大的情况。 D.取模优化众所周知，计算机中的取模运算非常之慢，而$long\\space long$的取模是最慢的，所以很多人程序的常数大的原因也是这个。所以我们可能会在某些人的程序中看到这样的函数 1ll mo(ll x,ll y){return x+y&gt;=mod?x+y-mod:x+y;} 这就是利用减法代替取模从而达到卡常的效果。 对于矩阵乘法也是这样。我们可以设定一个$ull$上界$Q=16ull*mod$，当超过这个上界时就可以直接用减法代替取模，因为当$mod$在$10^9$级别时，$ull$最多只能存下$16$个$mod\\times mod$相加。 当然中间过程需要$long\\space long$来存储，而最后的结果最好还是$int$类型。 所以取模次数由$O(n^3)$降到$O(n^2)$次 但实际效果略逊于$ikj$，可能是本机的问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stack&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout);using namespace std;char IN[1&lt;&lt;17],*SS=IN,*TT=IN;inline char gc(){return (SS==TT&amp;&amp;(TT=(SS=IN)+fread(IN,1,1&lt;&lt;17,stdin),SS==TT)?EOF:*SS++);}inline int read(){ int now=0,f=1;register char c=gc(); for(;!isdigit(c);c=='-'&amp;&amp;(f=-1),c=gc()); for(;isdigit(c);now=now*10+c-'0',c=gc()); return now*f;}const int maxn=100005;typedef unsigned long long ull;const int mod=1e9+7;const ull Q=16ull*mod*mod;int a[1100][1100];long long temp;ull b[1010][1010];ull c[1010][1010];ull mo(ull x,ull y){return x+y&gt;=Q?x+y-Q:x+y;}int main(){ freopen(\"a.out\",\"r\",stdin); freopen(\"x2.out\",\"w\",stdout); int n=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j)b[i][j]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j)c[i][j]=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) { temp=0; for(int k=1,s=1;k&lt;=n;++k,s++) { if(s==16)temp=mo(temp,b[i][k]*c[k][j]),s=1; else temp+=b[i][k]*c[k][j]; } a[i][j]=temp%mod; } for(int i=1;i&lt;=n;++i)printf(\"%d \",a[5][i]); printf(\"\\n\"); printf(\"Elapsed time:%.2lf secs.\\n\",1.0*clock()/1000.0); return 0;} 和$ikj$优化一起用的效果 E.特判优化特判矩阵的元素是否为$0$，如果是$0$可以直接$continue$,在稀疏矩阵里有奇效，由于数据比较难生成，所以不实际运行.还请见谅 感谢审核的$@ComeIntoPower$提出的宝贵意见。 另:测试数据均为以下代码生成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stack&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout);using namespace std;char IN[1&lt;&lt;17],*SS=IN,*TT=IN;inline char gc(){return (SS==TT&amp;&amp;(TT=(SS=IN)+fread(IN,1,1&lt;&lt;17,stdin),SS==TT)?EOF:*SS++);}inline int read(){ int now=0,f=1;register char c=gc(); for(;!isdigit(c);c=='-'&amp;&amp;(f=-1),c=gc()); for(;isdigit(c);now=now*10+c-'0',c=gc()); return now*f;}const int maxn=100005;int main(){ srand(time(NULL)*20020307%19260817); freopen(\"a.out\",\"w\",stdout); int n=1000; printf(\"1000\\n\"); for(int i=1;i&lt;=n;++i) { for(int j=1;j&lt;=n;++j) printf(\"%d \",rand()*10+50000); printf(\"\\n\"); } for(int i=1;i&lt;=n;++i) { for(int j=1;j&lt;=n;++j) printf(\"%d \",rand()*10+50000); printf(\"\\n\"); } // printf(\"Elapsed time:%.2lf secs.\\n\",1.0*clock()/1000.0); return 0;} 本文转载某作者（原谅我实在是找不到作者的名字）的文章 侵删","link":"/2019/07/11/matrix/"},{"title":"(英文)Ten C++11 Features Every C++ Developer Should Use","text":"转自Marius Bancila的文章 向原作者致敬！ This article discusses a series of features new to C++11 that all developers should learn and use. There are lots of new additions to the language and the standard library, and this article barely scratches the surface. However, I believe some of these new features should become routine for all C++ developers. You could probably find many similar articles evangelizing different C++11 features. This is my attempt to assemble a list of C++ features that should be a norm nowadays. autoBefore C++11 the auto keyword was used for storage duration specification. In the new standard its purpose was changed towards type inference. auto is now a sort of placeholder for a type, telling the compiler it has to deduce the actual type of a variable that is being declared from its initializer. It can be used when declaring variables in different scopes such as namespaces, blocks or initialization statement of for loops. 123auto i = 42; // i is an intauto l = 42LL; // l is an long longauto p = new foo(); // p is a foo* Using auto usually means less code (unless your type is int which is one letter shorter). Think of iterators in STL that you always had to write while iterating over containers. It makes obsolete creating typedefs just for the sake of simplicity. 12345std::map&lt;std::string, std::vector&lt;int&gt;&gt; map;for(auto it = begin(map); it != end(map); ++it) { ...} You should note that auto cannot be used as the return type of a function. However, you can use auto in place of the return type of function, but in this case the function must have a trailing return type. In this case auto does not tell the compiler it has to infer the type, it only instructs it to look for the return type at the end of the function. In the example below the return type of function compose is the return type of operator+ that sums values of types T1 and T2. 123456template &lt;typename T1, typename T2&gt;auto compose(T1 t1, T2 t2) -&gt; decltype(t1 + t2){ return t1+t2;}auto v = compose(2, 3.14); // v's type is double nullptrZero used to be the value of null pointers, and that has drawbacks due to the implicit conversion to integral types. The keyword nullptr denotes a value of type std::nullptr_t that represents the null pointer literal. Implicit conversions exists from nullptr to null pointer value of any pointer type and any pointer-to-member types, but also to bool (as false). But no implicit conversion to integral types exist. 12345678910111213141516void foo(int* p) {}void bar(std::shared_ptr&lt;int&gt; p) {}int* p1 = NULL;int* p2 = nullptr; if(p1 == p2){ ...}foo(nullptr);bar(nullptr);bool f = nullptr;int i = nullptr; // error: A native nullptr can only be converted to bool or, using reinterpret_cast, to an integral type For backward compatibility 0 is still a valid null pointer value. Range-based for loops(Foreach)C++11 augmented the for statement to support the “foreach” paradigm of iterating over collections. In the new form, it is possible to iterate over C-like arrays, initializer lists and anything for which the non-member begin() and end() functions are overloaded. This for each for is useful when you just want to get and do something with the elements of a collection/array and don’t care about indexes, iterators or number of elements. 12345678910111213141516171819202122std::map&lt;std::string, std::vector&lt;int&gt;&gt; map;std::vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(3);map[\"one\"] = v;for(const auto&amp; kvp : map) { std::cout &lt;&lt; kvp.first &lt;&lt; std::endl; for(auto v : kvp.second) { std::cout &lt;&lt; v &lt;&lt; std::endl; }}int arr[] = {1,2,3,4,5};for(int&amp; e : arr) { e = e*e;} Override and finalI always founded the virtual methods badly designed in C++ because there wasn’t (and still isn’t) a mandatory mechanism to mark virtual methods as overridden in derived classes. The virtual keyword is optional and that makes reading code a bit harder, because you may have to look through the top of the hierarchy to check if the method is virtual. I have always used, and encouraged people to use the virtual keyword on derived classes also, to make the code easier to read. However, there are subtle errors that can still arise. Take for instance the following example: 1234567891011class B {public: virtual void f(short) {std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;}};class D : public B{public: virtual void f(int) {std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;}}; D::f is supposed to override B::f. However, the signature differ, one takes a short, one takes an int, therefore B::f is just another method with the same name (and overload) and not an override. You may call f() through a pointer to B and expect to print D::f, but it’s printing B::f. Here is another subtle error: the parameters are the same, but the method in the base class is marked const, while me method in the derived is not. 1234567891011class B {public: virtual void f(int) const {std::cout &lt;&lt; \"B::f \" &lt;&lt; std::endl;}};class D : public B{public: virtual void f(int) {std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;}}; Again, these two are overloads and not overrides, so if you call f() through a pointer to B it will print B::f and not D::f. Fortunately there is now a way to describe your intentions. Two new special identifiers (not keywords) have been added: override, to indicate that a method is supposed to be an override of a virtual method in a base class, and final, to indicate that a derived class shall not override a virtual method. The first example would become: 1234567891011class B {public: virtual void f(short) {std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;}};class D : public B{public: virtual void f(int) override {std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;}}; This now triggers a compiler error (the same error you’d get for the second example too, if using the override specifier): ‘D::f’ : method with override specifier ‘override’ did not override any base class methods On the other hand if you intend to make a method impossible to override any more (down the hierarchy) mark it as final. That can be in the base class, or any derived class. If it’s in a derived classes you can use both the override and final specifiers. 1234567891011121314151617class B {public: virtual void f(int) {std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;}};class D : public B{public: virtual void f(int) override final {std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;}};class F : public D{public: virtual void f(int) override {std::cout &lt;&lt; \"F::f\" &lt;&lt; std::endl;}}; function declared as ‘final’ cannot be overridden by ‘F::f’ Strongly-typed enums“Traditional” enums in C++ have some drawbacks: they export their enumerators in the surrounding scope (which can lead to name collisions, if two different enums in the same have scope define enumerators with the same name), they are implicitly converted to integral types and cannot have a user-specified underlying type. These issues have been fixed in C++ 11 with the introduction of a new category of enums, called strongly-typed enums. They are specified with the enum class keywords. They no longer export their enumerators in the surrounding scope, are no longer implicitly converted to integral types and can have a user-specified underlying type (a feature also added for traditional enums). 12enum class Options {None, One, All};Options o = Options::All; Smart pointersThere have been tons of articles written on this subject, therefore I just want to mention the smart pointers with reference counting and auto releasing of owned memory that are available: unique_ptr: should be used when ownership of a memory resource does not have to be shared (it doesn’t have a copy constructor), but it can be transferred to another unique_ptr (move constructor exists). shared_ptr: should be used when ownership of a memory resource should be shared (hence the name). weak_ptr: holds a reference to an object managed by a shared_ptr, but does not contribute to the reference count; it is used to break dependency cycles (think of a tree where the parent holds an owning reference (shared_ptr) to its children, but the children also must hold a reference to the parent; if this second reference was also an owning one, a cycle would be created and no object would ever be released). On the other hand the auto_ptr is obsolete and should no longer be used. When you should unique_ptr and when you should use shared_ptr depends on the ownership requirements and I recommend reading this discussion. The first example below shows unique_ptr. If you want to transfer ownership of an object to another unique_ptr use std::move (I’ll discuss this function in the last paragraph). After the ownership transfer, the smart pointer that ceded the ownership becomes null and get() returns nullptr. 1234567891011121314void foo(int* p){ std::cout &lt;&lt; *p &lt;&lt; std::endl;}std::unique_ptr&lt;int&gt; p1(new int(42));std::unique_ptr&lt;int&gt; p2 = std::move(p1); // transfer ownershipif(p1) foo(p1.get());(*p2)++;if(p2) foo(p2.get()); The second example shows shared_ptr. Usage is similar, though the semantics are different since ownership is shared. 123456789101112void foo(int* p){}void bar(std::shared_ptr&lt;int&gt; p){ ++(*p);}std::shared_ptr&lt;int&gt; p1(new int(42));std::shared_ptr&lt;int&gt; p2 = p1; bar(p1); foo(p2.get()); The first declaration is equivalent to this one 1auto p3 = std::make_shared&lt;int&gt;(42); make_shared is a non-member function and has the advantage of allocating memory for the shared object and the smart pointer with a single allocation, as opposed to the explicit construction of a shared_ptr via the contructor, that requires at least two allocations. In addition to possible overhead, there can be situations where memory leaks can occur because of that. In the next example memory leaks could occur if seed() throws an error. 12345void foo(std::shared_ptr&lt;int&gt; p, int init){ *p = init;}foo(std::shared_ptr&lt;int&gt;(new int(42)), seed()); No such problem exists if using make_shared. The third sample shows usage of weak_ptr. Notice that you always must get a shared_ptr to the referred object by calling lock(), in order to access the object. 123456789101112auto p = std::make_shared&lt;int&gt;(42);std::weak_ptr&lt;int&gt; wp = p;{ auto sp = wp.lock(); std::cout &lt;&lt; *sp &lt;&lt; std::endl;}p.reset();if(wp.expired()) std::cout &lt;&lt; \"expired\" &lt;&lt; std::endl; If you try to lock on an expired weak_ptr (the object is weakly reference has been released) you get an empty shared_ptr. LambdasAnonymous functions, called lambda, have been added to C++ and quickly rose to prominence. It is a powerful feature borrowed from functional programming, that in turned enabled other features or powered libraries. You can use lambdas wherever a function object or a functor or a std::function is expected. You can read about the syntax here. 1234567891011std::vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(3);std::for_each(std::begin(v), std::end(v), [](int n) {std::cout &lt;&lt; n &lt;&lt; std::endl;});auto is_odd = [](int n) {return n%2==1;};auto pos = std::find_if(std::begin(v), std::end(v), is_odd);if(pos != std::end(v)) std::cout &lt;&lt; *pos &lt;&lt; std::endl; A bit trickier are recursive lambdas. Imagine a lambda that represents a Fibonacci function. If you attempt to write it using auto you get compilation error: 1auto fib = [&amp;fib](int n) {return n &lt; 2 ? 1 : fib(n-1) + fib(n-2);}; 1234error C3533: &apos;auto &amp;&apos;: a parameter cannot have a type that contains &apos;auto&apos;error C3531: &apos;fib&apos;: a symbol whose type contains &apos;auto&apos; must have an initializererror C3536: &apos;fib&apos;: cannot be used before it is initializederror C2064: term does not evaluate to a function taking 1 arguments The problem is auto means the type of the object is inferred from its initializer, yet the initializer contains a reference to it, therefore needs to know its type. This is a cyclic problem. The key is to break this dependency cycle and explicitly specify the function’s type using std::function. 1std::function&lt;int(int)&gt; lfib = [&amp;lfib](int n) {return n &lt; 2 ? 1 : lfib(n-1) + lfib(n-2);}; non-member begin() and end()You probably noticed I have used in the samples above non-member begin() and end() functions. These are a new addition to the standard library, promoting uniformity, consistency and enabling more generic programming. They work with all STL containers, but more than that they are overloadable, so they can be extended to work with any type. Overloads for C-like arrays are also provided. Let’s take for instance the previous example where I was printing a vector and then looking for its first odd element. If the std::vector was instead a C-like array, the code might have looked like this: 123456789int arr[] = {1,2,3};std::for_each(&amp;arr[0], &amp;arr[0]+sizeof(arr)/sizeof(arr[0]), [](int n) {std::cout &lt;&lt; n &lt;&lt; std::endl;});auto is_odd = [](int n) {return n%2==1;};auto begin = &amp;arr[0];auto end = &amp;arr[0]+sizeof(arr)/sizeof(arr[0]);auto pos = std::find_if(begin, end, is_odd);if(pos != end) std::cout &lt;&lt; *pos &lt;&lt; std::endl; With non-member begin() and end() it could be put as this: 1234567int arr[] = {1,2,3};std::for_each(std::begin(arr), std::end(arr), [](int n) {std::cout &lt;&lt; n &lt;&lt; std::endl;});auto is_odd = [](int n) {return n%2==1;};auto pos = std::find_if(std::begin(arr), std::end(arr), is_odd);if(pos != std::end(arr)) std::cout &lt;&lt; *pos &lt;&lt; std::endl; This is basically identical code to the std::vector version. That means we can write a single generic method for all types supported by begin() and end(). 12345678910111213141516171819202122232425262728293031template &lt;typename Iterator&gt;void bar(Iterator begin, Iterator end) { std::for_each(begin, end, [](int n) {std::cout &lt;&lt; n &lt;&lt; std::endl;}); auto is_odd = [](int n) {return n%2==1;}; auto pos = std::find_if(begin, end, is_odd); if(pos != end) std::cout &lt;&lt; *pos &lt;&lt; std::endl;}template &lt;typename C&gt;void foo(C c){ bar(std::begin(c), std::end(c));}template &lt;typename T, size_t N&gt;void foo(T(&amp;arr)[N]){ bar(std::begin(arr), std::end(arr));}int arr[] = {1,2,3};foo(arr);std::vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(3);foo(v); static_assert and type traitsstatic_assert performs an assertion check at compile-time. If the assertion is true, nothing happens. If the assertion is false, the compiler displays the specified error message. 12345678910111213template &lt;typename T, size_t Size&gt;class Vector{ static_assert(Size &lt; 3, \"Size is too small\"); T _points[Size];};int main(){ Vector&lt;int, 16&gt; a1; Vector&lt;double, 2&gt; a2; return 0;} 1234567error C2338: Size is too smallsee reference to class template instantiation &apos;Vector&lt;T,Size&gt;&apos; being compiled with [ T=double, Size=2 ] static_assert becomes more useful when used together with type traits. These are a series of classes that provide information about types at compile time. They are available in the header. There are several categories of classes in this header: helper classes, for creating compile-time constants, type traits classes, to get type information at compile time, and type transformation classes, for getting new types by applying transformation on existing types. In the following example function add is supposed to work only with integral types. 12345template &lt;typename T1, typename T2&gt;auto add(T1 t1, T2 t2) -&gt; decltype(t1 + t2){ return t1 + t2;} However, there are no compiler errors if one writes 12std::cout &lt;&lt; add(1, 3.14) &lt;&lt; std::endl;std::cout &lt;&lt; add(\"one\", 2) &lt;&lt; std::endl; The program actually prints 4.14 and “e”. But if we add some compile-time asserts, both these lines would generate compiler errors. 12345678template &lt;typename T1, typename T2&gt;auto add(T1 t1, T2 t2) -&gt; decltype(t1 + t2){ static_assert(std::is_integral&lt;T1&gt;::value, \"Type T1 must be integral\"); static_assert(std::is_integral&lt;T2&gt;::value, \"Type T2 must be integral\"); return t1 + t2;} 1234567891011121314error C2338: Type T2 must be integralsee reference to function template instantiation &apos;T2 add&lt;int,double&gt;(T1,T2)&apos; being compiled with [ T2=double, T1=int ]error C2338: Type T1 must be integralsee reference to function template instantiation &apos;T1 add&lt;const char*,int&gt;(T1,T2)&apos; being compiled with [ T1=const char *, T2=int ] ##Move semantics This is yet another important and well covered topic from C++11, that one could write a series of articles, not just a paragraph. Therefore I will not get into too many details, but encourage you to find additional readings, if you’re not already familiar with the topic. C++11 has introduced the concept of rvalue references (specified with &amp;&amp;) to differentiate a reference to an lvalue or an rvalue. An lvalue is an object that has a name, while an rvalue is an object that does not have a name (a temporary object). The move semantics allow modifying rvalues (previously considered immutable and indistinguishable from const T&amp; types). A C++ class/struct used to have some implicit member functions: default constructor (only if another constructor is not explicitly defined) and copy constructor, a destructor and a copy assignment operator. The copy constructor and the copy assignment operator perform a bit-wise (or shallow) copy, i.e. copying the variables bitwise. That means if you have a class that contains pointers to some objects, they just copy the value of the pointers and not the objects they point to. This might be OK in some cases, but for many cases you actually want a deep-copy, meaning that you want to copy the objects pointers refer to, and not the values of the pointers. In this case you have to explicitly write copy constructor and copy assignment operator to perform a deep-copy. What if the object you initialize or copy from is an rvalue (a temporary). You still have to copy its value, but soon after the rvalue goes away. That means an overhead of operations, including allocations and memory copying that after all, should not be necessary. Enter the move constructor and move assignment operator. These two special functions take a T&amp;&amp; argument, which is an rvalue. Knowing that fact, they can modify the object, such as “stealing” the objects their pointers refer to. For instance, a container implementation (such as a vector or a queue) may have a pointer to an array of elements. When an object is instantiating from a temporary, instead of allocating another array, copying the values from the temporary, and then deleting the memory from the temporary when that is destroyed, we just copy the value of the pointer that refers to the allocated array, thus saving an allocation, copying a sequence of elements, and a later de-allocation. The following example shows a dummy buffer implementation. The buffer is identified by a name (just for the sake of showing a point revealed below), has a pointer (wrapper in an std::unique_ptr) to an array of elements of type T and variable that tells the size of the array. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697template &lt;typename T&gt;class Buffer { std::string _name; size_t _size; std::unique_ptr&lt;T[]&gt; _buffer;public: // default constructor Buffer(): _size(16), _buffer(new T[16]) {} // constructor Buffer(const std::string&amp; name, size_t size): _name(name), _size(size), _buffer(new T[size]) {} // copy constructor Buffer(const Buffer&amp; copy): _name(copy._name), _size(copy._size), _buffer(new T[copy._size]) { T* source = copy._buffer.get(); T* dest = _buffer.get(); std::copy(source, source + copy._size, dest); } // copy assignment operator Buffer&amp; operator=(const Buffer&amp; copy) { if(this != &amp;copy) { _name = copy._name; if(_size != copy._size) { _buffer = nullptr; _size = copy._size; _buffer = _size &gt; 0 &gt; new T[_size] : nullptr; } T* source = copy._buffer.get(); T* dest = _buffer.get(); std::copy(source, source + copy._size, dest); } return *this; } // move constructor Buffer(Buffer&amp;&amp; temp): _name(std::move(temp._name)), _size(temp._size), _buffer(std::move(temp._buffer)) { temp._buffer = nullptr; temp._size = 0; } // move assignment operator Buffer&amp; operator=(Buffer&amp;&amp; temp) { assert(this != &amp;temp); // assert if this is not a temporary _buffer = nullptr; _size = temp._size; _buffer = std::move(temp._buffer); _name = std::move(temp._name); temp._buffer = nullptr; temp._size = 0; return *this; }};template &lt;typename T&gt;Buffer&lt;T&gt; getBuffer(const std::string&amp; name) { Buffer&lt;T&gt; b(name, 128); return b;}int main(){ Buffer&lt;int&gt; b1; Buffer&lt;int&gt; b2(\"buf2\", 64); Buffer&lt;int&gt; b3 = b2; Buffer&lt;int&gt; b4 = getBuffer&lt;int&gt;(\"buf4\"); b1 = getBuffer&lt;int&gt;(\"buf5\"); return 0;} The default copy constructor and copy assignment operator should look familiar. What’s new to C++11 is the move constructor and move assignment operator, implemented in the spirit of the aforementioned move semantics. If you run this code you’ll see that when b4 is constructed, the move constructor is called. Also, when b1 is assigned a value, the move assignment operator is called. The reason is the value returned by getBuffer() is a temporary, i.e. an rvalue. You probably noticed the use of std::move in the move constructor, when initializing the name variable and the pointer to the buffer. The name is actually a string, and std::string also implements move semantics. Same for the std::unique_ptr. However, if we just said _name(temp._name) the copy constructor would have been called. For _buffer that would not have been even possible because std::unique_ptr does not have a copy constructor. But why wasn’t the move constructor for std::string called in this case? Because even if the object the move constructor for Buffer is called with is an rvalue, inside the constructor it is actually an lvalue. Why? Because it has a name, “temp“ and a named object is an lvalue. To make it again an rvalue (and be able to invoke the appropriate move constructor) one must use std::move. This function just turns an lvalue reference into an rvalue reference. UPDATE: Though the purpose of this example was to show how move constructor and move assignment operator should be implemented, the exact details of an implementation may vary. An alternative implementation was provided by Member 7805758 in the comments. To be easier to see it I will show it here: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename T&gt;class Buffer{ std::string _name; size_t _size; std::unique_ptr&lt;T[]&gt; _buffer; public: // constructor Buffer(const std::string&amp; name = \"\", size_t size = 16): _name(name), _size(size), _buffer(size? new T[size] : nullptr) {} // copy constructor Buffer(const Buffer&amp; copy): _name(copy._name), _size(copy._size), _buffer(copy._size? new T[copy._size] : nullptr) { T* source = copy._buffer.get(); T* dest = _buffer.get(); std::copy(source, source + copy._size, dest); } // copy assignment operator Buffer&amp; operator=(Buffer copy) { swap(*this, copy); return *this; } // move constructor Buffer(Buffer&amp;&amp; temp):Buffer() { swap(*this, temp); } friend void swap(Buffer&amp; first, Buffer&amp; second) noexcept { using std::swap; swap(first._name , second._name); swap(first._size , second._size); swap(first._buffer, second._buffer); }}; ConclusionsThere are many more things to say about C++11; this was just one of many possible beginnings. This article presented a series of core language and standard library features that every C++ developer should use. However, I recommend you additional readings, at least for some of these features. 还是喜欢看原版英文……文章翻译：http://blog.jobbole.com/44015/","link":"/2019/05/31/TenC11Features/"}],"tags":[{"name":"滑稽","slug":"滑稽","link":"/tags/滑稽/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"背包","slug":"背包","link":"/tags/背包/"},{"name":"高精度","slug":"高精度","link":"/tags/高精度/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"二进制","slug":"二进制","link":"/tags/二进制/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"类","slug":"类","link":"/tags/类/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"NOIP","slug":"NOIP","link":"/tags/NOIP/"},{"name":"题解","slug":"题解","link":"/tags/题解/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"难度★☆☆☆☆","slug":"难度★☆☆☆☆","link":"/tags/难度★☆☆☆☆/"},{"name":"难度★★☆☆☆","slug":"难度★★☆☆☆","link":"/tags/难度★★☆☆☆/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"难度★★★☆☆","slug":"难度★★★☆☆","link":"/tags/难度★★★☆☆/"},{"name":"库函数","slug":"库函数","link":"/tags/库函数/"},{"name":"教程","slug":"教程","link":"/tags/教程/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"矩阵","slug":"矩阵","link":"/tags/矩阵/"},{"name":"英文","slug":"英文","link":"/tags/英文/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"DP","slug":"DP","link":"/categories/DP/"},{"name":"运算","slug":"运算","link":"/categories/运算/"},{"name":"C++11","slug":"C-11","link":"/categories/C-11/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"博客","slug":"博客","link":"/categories/博客/"},{"name":"数论","slug":"数论","link":"/categories/数论/"}]}